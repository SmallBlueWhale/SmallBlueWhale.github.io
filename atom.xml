<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SmallBlueWhale&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-01-16T05:13:04.750Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>SmallBlueWhale</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android表层知识里面的原理</title>
    <link href="http://yoursite.com/2016/12/12/Android%E8%A1%A8%E5%B1%82%E7%9F%A5%E8%AF%86%E9%87%8C%E9%9D%A2%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2016/12/12/Android表层知识里面的原理/</id>
    <published>2016-12-11T17:23:00.000Z</published>
    <updated>2017-01-16T05:13:04.750Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发进程通信"><a href="#并发进程通信" class="headerlink" title="并发进程通信"></a>并发进程通信</h1><p><strong>文件传输</strong>  </p>
<ul>
<li>writeObject的方式  </li>
</ul>
<p><strong>bundle</strong>  </p>
<p><strong>SharePreference</strong>  </p>
<ul>
<li>SharePreference的进程访问不可靠                             <ul>
<li>本质上shareprefence属于文件的一种，但由于系统对它的读写有一定的缓存策略，即在内存中会有一份SharePrefences文件的缓存，因此在多线程模式下，系统对它的读写就变的不可靠了</li>
</ul>
</li>
</ul>
<p><strong>Messenger</strong>  </p>
<p><strong>SharePreference</strong>  </p>
<h1 id="To-do-后续补充"><a href="#To-do-后续补充" class="headerlink" title="To do(后续补充)"></a>To do(后续补充)</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;并发进程通信&quot;&gt;&lt;a href=&quot;#并发进程通信&quot; class=&quot;headerlink&quot; title=&quot;并发进程通信&quot;&gt;&lt;/a&gt;并发进程通信&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;文件传输&lt;/strong&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;writeObject的方式  &lt;
    
    </summary>
    
      <category term="tips" scheme="http://yoursite.com/categories/tips/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android学习总结</title>
    <link href="http://yoursite.com/2016/12/12/Android%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2016/12/12/Android学习总结/</id>
    <published>2016-12-11T17:23:00.000Z</published>
    <updated>2017-01-16T05:13:14.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="View学习中的一些难点记录"><a href="#View学习中的一些难点记录" class="headerlink" title="View学习中的一些难点记录"></a>View学习中的一些难点记录</h1><ul>
<li>what is the different about getLeft(),getX()？  </li>
</ul>
<p><code>Position</code>  </p>
<ul>
<li><a href="&quot;http://gold.xitu.io/entry/571a591a2e958a006be9f473&quot;">这个部分可以参照这个地方去理解</a> </li>
</ul>
<p><strong>The geometry of a view is that of a rectangle. A view has a location, expressed as a pair of left and top coordinates, and two dimensions, expressed as a width and a height. The unit for location and dimensions is the pixel.</strong></p>
<p><strong>It is possible to retrieve the location of a view by invoking the methods getLeft() and getTop(). The former returns the left, or X, coordinate of the rectangle representing the view. The latter returns the top, or Y, coordinate of the rectangle representing the view. These methods both return the location of the view relative to its parent. For instance, when getLeft() returns 20, that means the view is located 20 pixels to the right of the left edge of its direct parent.</strong></p>
<p><strong>In addition, several convenience methods are offered to avoid unnecessary computations, namely getRight() and getBottom(). These methods return the coordinates of the right and bottom edges of the rectangle representing the view. For instance, calling getRight() is similar to the following computation: getLeft() + getWidth() (see Size for more information about the width.)</strong>  </p>
<pre><code>right = left + width;

bottom = top + height;
</code></pre><p>这里的意思是getLeft其实是相对父view的位置，而getX则是相对整个根布局的位置  </p>
<ul>
<li><p>View的滑动                            </p>
<ul>
<li><a href="&quot;http://gold.xitu.io/entry/576a264f80dda4005fb17639&quot;">关于getscrollX以及ScrollX的理解和梳理</a> </li>
</ul>
</li>
<li><p>关于自定义view中onMeasure方法的模板  </p>
<pre><code>private Bitmap mBitmap;
 private void init() {
mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.meinv);
}

@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
// 获取宽度测量规格中的mode和size
int widthMode = MeasureSpec.getMode(widthMeasureSpec);
int widthSize = MeasureSpec.getSize(widthMeasureSpec);
int heightMode = MeasureSpec.getMode(heightMeasureSpec);
int heightSize = MeasureSpec.getSize(heightMeasureSpec);
// 声明一个临时变量来存储计算出的测量值
int  heightResult = 0;
int widthResult = 0;

 /*
 * 如果父容器心里有数
 */
if (widthMode == MeasureSpec.EXACTLY) {
    // 那么子view就用父容器给定尺寸
    widthResult = widthSize;
}
/*
 * 如果父容器不确定自身大小
 */
else{
    // 那么子view可要自己看看自己需要多大了
    widthResult = mBitmap.getWidth()+getPaddingLeft()+getPaddingRight();
    /*
       * 如果爹给儿子的是一个限制值
     */
    if (widthMode == MeasureSpec.AT_MOST) {
        // 那么儿子自己的需求就要跟爹的限制比比看谁小要谁
        widthResult = Math.min(widthSize, widthResult);
    }
}

if (heightMode == MeasureSpec.EXACTLY) {
    heightResult = widthSize;
}else{
    //考虑padding
    heightResult = mBitmap.getHeight()+getPaddingBottom()+getPaddingTop();
    if (heightMode == MeasureSpec.AT_MOST) {
        heightResult = Math.min(widthSize, heightResult);
    }
}
// 设置测量尺寸
setMeasuredDimension(widthResult, heightResult);
}
</code></pre></li>
<li><p>关于自定义View滑动冲突的拦截以及模板总结、</p>
</li>
</ul>
<h1 id="外部拦截法"><a href="#外部拦截法" class="headerlink" title="外部拦截法"></a>外部拦截法</h1><h2 id="事件分发的过程图"><a href="#事件分发的过程图" class="headerlink" title="事件分发的过程图"></a>事件分发的过程图</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://ww2.sinaimg.cn/large/005Xtdi2jw1f88i0q8uozj30nm0kqwhm.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>外部拦截法即事件都经过父容器处理，如果父容器需要事件就处理事件，不需要则不拦截，下面来看一下伪代码：</p>
<pre><code>@Override
public boolean onInterceptTouchEvent(MotionEvent event) {
    boolean intercept = false;
    int x = (int) event.getX();
    int y = (int) event.getY();
    int action = event.getActionMasked();
    switch (action) {
        case MotionEvent.ACTION_DOWN:
            //如果希望子view能接收到事件，DOWN必然要返回false
            intercept = false;
            break;

        case MotionEvent.ACTION_MOVE:
            //如果需要拦截事件，就返回true
            if (needIntercept(event)) {
                intercept = true;
            } else {
                intercept = false;
            }
            break;

        case MotionEvent.ACTION_UP:
            //手指抬起，必须返回false，因为返回值对自己没有影响，而对子view可能有影响
            intercept = false;
            break;
    }
    //重新设置最后一次位置
    mLastEventX = x;
    mLastEventY = y;
    return intercept;
}

private boolean needIntercept(MotionEvent event) {
    return false;
}
</code></pre><p>下面来分析一下这段伪代码的意思：</p>
<ol>
<li>首先ACTION_DOWN必须返回false，否则子view无法接收到事件，事件都会由自己处理</li>
<li>对应ACTION_MOVE则对自己根据情况处理，需要就拦截，否则不拦截</li>
<li>最后是ACTION_UP，必须返回false，原因有：<ul>
<li>ACTION_UP的返回值对自身并没有影响，自身始终能接收到事件</li>
<li>如果子一些列事件中，ViewGroup都始终没有拦截事件，却在ACTION_UP中返回true，这样导致子view无法接收到UP事件，那么就会影响子view的click事件，或者其他逻辑处理</li>
</ul>
</li>
<li><p>是否需要拦截事件都交给needIntercept方法处理，这个处理是根据业务来处理的，还可如果我们无法确定某些因素，还可以通过设置回调接口来处理，让其他对象通过接口来告知感兴趣的事。</p>
<p>如下面代码：</p>
<pre><code> private boolean needIntercept(MotionEvent event) {
    if (mEventCallback != null) {
       return mEventCallback.isCanIntercept();
    }
    return false;
}

public EventCallback mEventCallback;

public void setEventCallback(EventCallback eventCallback) {
    mEventCallback = eventCallback;
}
public interface EventCallback{
    boolean isCanIntercept();
}
</code></pre></li>
</ol>
<p>在外部拦截法中，子view最好不要使用requestDisallowInterceptTouchEvent来干预事件的处理</p>
<h1 id="内部拦截法"><a href="#内部拦截法" class="headerlink" title="内部拦截法"></a>内部拦截法</h1><p>内部拦截是指父容器不拦截任何事件，所有事件都传递给子view，如果子元素需要事件就直接消耗，否则交给父容器处理，这种拦截法需要配合requestDisallowInterceptTouchEvent方法来使用。我们需要重写子view的dispatchTouchEvent方法。</p>
<pre><code>private int mLastX, mLastY;
  @Override
  public boolean dispatchTouchEvent(MotionEvent event) {
      int action = event.getActionMasked();
      int x = (int) event.getX();
      int y = (int) event.getY();
      switch (action) {
          case MotionEvent.ACTION_DOWN:
              //不让父View拦截事件
              mLastX = x;
              mLastY = y;
              getParent().requestDisallowInterceptTouchEvent(true);
              break;

          case MotionEvent.ACTION_MOVE:
              //如果需要拦截事件，就返回true
              if (!needIntercept(event)) {
                  getParent().requestDisallowInterceptTouchEvent(false);
              }
              break;

          case MotionEvent.ACTION_UP:
              //手指抬起，必须返回false，因为返回值对自己没有影响，而对子view可能有影响
              break;
      }
      mLastX = x;
      mLastY = y;
      return super.dispatchTouchEvent(event);
  }
</code></pre><p>代码说明：</p>
<ul>
<li>首先，必须假定父view不拦截DOWN事件而拦截其他事件，否则子view无法获取任何事件。在子view调用requestDisallowInterceptTouchEvent(false)后，父view才能继续拦截事件</li>
<li>其次在ACTION_DOWN时，调用requestDisallowInterceptTouchEvent(true)来不允许父View拦截事件</li>
<li>ACTION_MOVE中如果needIntercept返回false，则调用requestDisallowInterceptTouchEvent(false)让父view重新拦截事件，需要注意的是，一点调用此方法，就表示放弃了同系列的事件的所有事件。</li>
<li>最后调用requestDisallowInterceptTouchEvent后触发我们的onTouchEvent方法，处理时间</li>
</ul>
<p>所以父元素的拦截逻辑如下：</p>
<pre><code>@Override
  public boolean onInterceptHoverEvent(MotionEvent event) {
      boolean intercept = false;
      int x = (int) event.getX();
      int y = (int) event.getY();
      int action = event.getActionMasked();
      if(action == MotionEvent.ACTION_DOWN){
               return false;
      }else{
               return true
      }
 }  
</code></pre><h1 id="重定义dispatchTouchEvent方法"><a href="#重定义dispatchTouchEvent方法" class="headerlink" title="重定义dispatchTouchEvent方法"></a>重定义dispatchTouchEvent方法</h1><p>上面两种方法基本还是尊重系统的事件分发机制，但是还是有一些情况无法满足，这时候，我们需要根据业务需求来重新定义事件分发了。</p>
<p>比如一个下拉刷新模式</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="img/010_demopng.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>首先我们定义：<br>下拉刷新容器为： A<br>列表布局为ListView：B<br>刷新头为：C</p>
<p>逻辑如下：<br>首先A或获取到事件，如果手机方向被认定为垂直滑动，A要判断C的位置和滑动方向：</p>
<p>1，C刚好隐藏，此时向下滑动，B这时无法向下滑动</p>
<p>A需要拦截事件，自己处理，让C显示出来，此时A需要拦截事件，自己处理，让C显示出来，如果手指又向上滑动，则A又要判断C是否隐藏，没有隐藏还是A拦截并处理事件，当C完全隐藏后，又要吧事件交给B处理，B来实现自己列表View该有的特性</p>
<p>就这个逻辑上述方案1和方案2就无法满足，<strong>因为系统的事件分发有一个特点</strong>：</p>
<ul>
<li><p><strong>当一个ViewGroup开始拦截并处理事件后，这个事件只能由它来处理，不可能再把事件交给它的子view处理，要么它消费事件，要么最后交给Activity的onTouchEvent处理</strong></p>
<blockquote>
<p>在代码中就是，只要ViewGroup拦截了事件，他的dispatchTouchEvent方法中接收事件的子view就会被置为null，</p>
</blockquote>
</li>
</ul>
<p>此特点：</p>
<ul>
<li>套用到方案1外部拦截法就是，在MOVE中，开始拦截事件，View收到一个Cancel事件后，之后都无法获取到同系列事件了。</li>
<li>套用到方案2就是在MOVE中调用requestDisallowInterceptTouchEvent(false)就表示完全放弃同系列事件的所有事件了</li>
</ul>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p>说了这么方案，现在来一个实例，需求<br>定义一个ViewGroup，布局方向为横向布局，可以左右滑动切换子view，同时只显示一个子view，类似ViewPager，其次ViewGroup内部放置ListView，来制造滑动冲突，我们需要解决这种冲突。</p>
<p>我们的自定义HScrollLayout代码如下：</p>
<pre><code>package com.ztiany.view.views;

import android.content.Context;
import android.util.AttributeSet;
import android.util.Log;
import android.view.MotionEvent;
import android.view.VelocityTracker;
import android.view.View;
import android.view.ViewGroup;
import android.view.animation.AccelerateDecelerateInterpolator;
import android.widget.Scroller;

/**
 * @author Ztiany
 *         email 1169654504@qq.com &amp; ztiany3@gmail.com
 *         date 2015-12-03 15:23
 *         description
 *         vsersion
 */
public class HScrollLayout extends ViewGroup {


    public HScrollLayout(Context context) {
        this(context, null);
    }

    public HScrollLayout(Context context, AttributeSet attrs) {
        this(context, attrs, 0);
    }

    public HScrollLayout(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        init();
    }

    public static final String TAG = HScrollLayout.class.getSimpleName();

    private int mLastEventX, mLastEventY;
    private VelocityTracker mVelocityTracker;
    private Scroller mScroller;
    private int mWidth;
    private int mCurrentPage;


    private void init() {
        //设置方向为横向布局
        mScroller = new Scroller(getContext(), new AccelerateDecelerateInterpolator());
        mVelocityTracker = VelocityTracker.obtain();

    }


    @Override
    public boolean onInterceptTouchEvent(MotionEvent event) {

        if (getChildCount() &lt; 0) {
            return false;
        }


        boolean intercept = false;
        int x = (int) event.getX();
        int y = (int) event.getY();
        int action = event.getActionMasked();
        switch (action) {
            case MotionEvent.ACTION_DOWN:

                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                    intercept = true;
                } else {
                    //如果希望子view能接收到事件，DOWN必然要返回false
                    intercept = false;
                    mLastEventX = x;
                    mLastEventX = y;
                }


                break;

            case MotionEvent.ACTION_MOVE:
                //计算移动差
                int dx = x - mLastEventX;
                int dy = y - mLastEventY;
                if (Math.abs(dx) &gt; Math.abs(dy)) {
                    intercept = true;
                } else {
                    intercept = false;
                }
                break;

            case MotionEvent.ACTION_UP:
                //手指抬起，必须返回false，因为返回值对自己没有影响，而对子view可能有影响
                intercept = false;
                break;
        }
        mLastEventX = x;
        mLastEventY = y;
        return intercept;

    }

    @Override
    protected void onLayout(boolean changed, int l, int t, int r, int b) {
        Log.d(TAG, &quot;l:&quot; + l);
        Log.d(TAG, &quot;t:&quot; + t);
        Log.d(TAG, &quot;r:&quot; + r);
        Log.d(TAG, &quot;b:&quot; + b);
        int left = l, top = t, right = r, bottom = b;
        if (changed) {
            int childCount = getChildCount();
            View child;
            for (int i = 0; i &lt; childCount; i++) {
                child = getChildAt(i);
                if (child.getVisibility() == View.GONE) {
                    continue;
                }
                child.layout(left, top, left + child.getMeasuredWidth(), bottom);
                left += child.getMeasuredWidth();
            }
        }

    }


    @Override
    public boolean onTouchEvent(MotionEvent event) {

        mVelocityTracker.addMovement(event);
        int x = (int) event.getX();
        int y = (int) event.getY();
        int action = event.getActionMasked();
        switch (action) {
            case MotionEvent.ACTION_DOWN:
                mLastEventX = x;
                mLastEventX = y;
                break;

            case MotionEvent.ACTION_MOVE:
                int dx = x - mLastEventX;
                scrollBy(-dx, 0);

                break;

            case MotionEvent.ACTION_UP:
            case MotionEvent.ACTION_CANCEL:
                //将要滑动的距离
                int distanceX;
                mVelocityTracker.computeCurrentVelocity(1000);
                float xVelocity = mVelocityTracker.getXVelocity();

                Log.d(TAG, &quot;xVelocity:&quot; + xVelocity);

                if (Math.abs(xVelocity) &gt; 50) {
                    if (xVelocity &gt; 0) {//向左
                        mCurrentPage--;
                    } else {
                        mCurrentPage++;
                    }


                } else {
                    // 不考虑加速度
                    Log.d(TAG, &quot;getScrollX():&quot; + getScrollX());
                    if (getScrollX() &lt; 0) {//说明超出左边界
                        mCurrentPage = 0;
                    } else {
                        int childCount = getChildCount();
                        int maxScroll = (childCount - 1) * mWidth;
                        Log.d(TAG, &quot;maxScroll:&quot; + maxScroll);
                        if (getScrollX() &gt; maxScroll) {//超出了右边界
                            mCurrentPage = getChildCount() - 1;
                        } else {

                            //在边界范围内滑动
                            int currentScrollX = mCurrentPage * mWidth;//已近产生的偏移
                            int offset = getScrollX() % mWidth;
                            Log.d(TAG, &quot;mWidth:&quot; + mWidth);
                            Log.d(TAG, &quot;offset:&quot; + offset);

                            if (currentScrollX &gt; Math.abs(getScrollX())) {//向左偏移

                                if (offset &lt; (mWidth - mWidth / 3)) {//小于其 2/3
                                    mCurrentPage--;
                                } else {

                                }

                            } else {//向右偏移

                                if (offset &gt; mWidth / 3) {//小于其 2/3
                                    mCurrentPage++;
                                } else {

                                }

                            }

                        }
                    }
                    //不考虑加速度
                }
                mCurrentPage = (mCurrentPage &lt; 0) ? 0 : ((mCurrentPage &gt; (getChildCount() - 1)) ? (getChildCount() - 1) : mCurrentPage);
                distanceX = mCurrentPage * mWidth - getScrollX();
                Log.d(TAG, &quot;distanceX:&quot; + distanceX);
                smoothScroll(distanceX, 0);
                mVelocityTracker.clear();
                break;
        }
        mLastEventX = x;
        mLastEventY = y;
        //返回true，处理事件
        return true;
    }

    private void smoothScroll(int distanceX, int distanceY) {
        mScroller.startScroll(getScrollX(), 0, distanceX, 0, 500);
        invalidate();
    }

    @Override
    public void computeScroll() {
        if (mScroller.computeScrollOffset()) {
            scrollTo(mScroller.getCurrX(), mScroller.getCurrY());
            invalidate();
        }
    }

    /**
     * 重写测量逻辑
     *
     * @param widthMeasureSpec
     * @param heightMeasureSpec 这里我们不考虑wrap_content的情况,也不考虑子view的margin情况
     */
    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {

        int widthSize = MeasureSpec.getSize(widthMeasureSpec);
        int heightSize = MeasureSpec.getSize(heightMeasureSpec);

        int childCount = getChildCount();
        View child;
        for (int i = 0; i &lt; childCount; i++) {
            child = getChildAt(i);
            if (child.getVisibility() == View.GONE) {
                continue;
            }
            measureChild(child, MeasureSpec.makeMeasureSpec(widthSize, MeasureSpec.EXACTLY),
                    MeasureSpec.makeMeasureSpec(heightSize, MeasureSpec.EXACTLY));
        }


        setMeasuredDimension(widthSize, heightSize);
    }

    @Override
    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
        mWidth = w;
    }
}
</code></pre><p><img src="img/010_view滑动冲突解决方案.gif" alt=""></p>
<h1 id="事件分发流程"><a href="#事件分发流程" class="headerlink" title="事件分发流程"></a>事件分发流程</h1><p>通过前面的事件分发研究，我们可以总结出事件分发的流程：</p>
<p>在ViewGroup的dispatchTouchEvent中</p>
<ol>
<li><p>处理DOWN事件，在down事件中，如果拦截了事件则自己处理(onTouchEvent方法被调用)，子无法在获取事件了，如果不拦截DOWN事件，则会从外到内查找是否有子view能处理事件，如果有一个子view可以处理事件(down返回true)，则接下来的事件交给子view处理，ViewGroup的onInterceptTouchEvent方法还是会被调用，一旦其返回true，那么ViewGroup开始拦截事件，而子view以一个cancel事件结束</p>
</li>
<li><p>接下来的move和up事件，如果在down中没有找到可以处理事件的子view，则自己处理接下来的事件。</p>
</li>
<li><p>如果有子view可以处理事件，并且不拦截事件，则把事件都交给子view处理，一旦ViewGroup开始拦截，那么接收事件的子view将会被赋值为null，接下来事件遵循第二点。</p>
</li>
<li><p>如果子view能接收到DWON事件，并且在接收到事件事件后，调用requestDisallowInterceptTouchEvent(true)方法，ViewGroup无法再拦截事件，也就说requestDisallowInterceptTouchEvent优先级高于onInterceptTouchEvent，但是requestDisallowInterceptTouchEvent不能干预父view对DOWN事件的处理。对于DOWN事件onInterceptTouchEvent说了算。</p>
</li>
</ol>
<h2 id="关于事件分发的规律总结-参考Android开发艺术探索"><a href="#关于事件分发的规律总结-参考Android开发艺术探索" class="headerlink" title="关于事件分发的规律总结(参考Android开发艺术探索)"></a>关于事件分发的规律总结(参考Android开发艺术探索)</h2><ol>
<li><p><strong>同一个事件序列</strong>是指从手指触摸屏幕那一刻起，到手指离开屏幕的那一刻结束,所以一些列事件由：<br><code>一个DOWN + 不数量的MOVE + 一个UP事件(可能CANCEL)</code><br>组成</p>
</li>
<li><p>正常情况下，<strong>一个事件只能被一个View拦截和消费</strong>，也就是说同一个事件不可能被两个View共同来消费，但是如果一个View接收到事件并处理后有分发给其他View处理除外。</p>
</li>
<li><p>如果一个ViewGroup能接收到事件，并且开始拦截事件，那么这一系列事件只能由它来处理。并且他的onInterceptTouchEvent方法不会再被调用。</p>
<p>关于ViewGroup能否接收到事件又分为两种：</p>
<ul>
<li>在DOWN就开始拦截事件</li>
<li>在DOWN没有拦截事件，但是子view处理了DOWN事件并且没有改变FLAG_DISALLOW_INTERCEPT这个标志位来不允许父View拦截事件，之后ViewGroup的onInterceptTouchEvent依然会被调用，如果返回true，ViewGroup还是可以拦截事件，之后可接收事件的子View收到一个CANCEL事件，然后在ViewGroup中被置为null</li>
</ul>
</li>
<li><p>FLAG_DISALLOW_INTERCEPT 和 touchTarget在一系列事件的开始和结尾都会被重置,也就是说子View无法使用requestDisallowInterceptTouchEvent方法来要影响DOWN事件，如果ViewGroup在DOWN就开始拦截事件，子view不可能再得到事件</p>
</li>
<li><p>如果一个View开始接收事件，如果它不消费DOWN事件(DOWN中返回false)，那么它不会接收到同系列事件中接下来的事件，在源码中的体现就是，ViewGroup在DOWN事件中没有找到可以处理事件的子view，接下来的同系列事件就会自己处理，即他的onTouchEvent方法被调用</p>
</li>
<li><p>如果一个View开始接收事件，如果它消费了DOWN事件(DOWN中返回true),但是接下来的事件它返回false，这个View依然能继续接收这一系列的事件，直到UP(或CANCEL)事件结束，最终事件会回到Activity的onTouchEvent方法，由Activity处理</p>
</li>
<li><p>View不拦截事件，它接收到事件会里面调用onTouchEvent方法，ViewGroup默认不拦截事件</p>
</li>
<li><p>如果一个View是可以被click或者longClick的，那么它的onTouchEvent方法默认都会消费事件，即使它是不可用的(disable)，disable只会导致click或者longClick不被调用：</p>
<ul>
<li>onClick发生前提，View可以点击，View能接收到Down和Up事件</li>
</ul>
</li>
<li><p>focus对View的点击事件有影响，View的isFocusable和isFocusableInTouchMode为true并且当前没有获取到焦点，则会先请求焦点，此次点击不会响应click等事件</p>
</li>
<li><p>事件是由外到内进行传递的，由内到外进行处理的，即事件总是先传给根View，再由根View传递给子View，而默认的处理顺序是子View到根View，ViewGroup可以全部拦截事件，子View可以调用requestDisallowInterceptTouchEvent干预父View的事件分发(DOWN事件无法被干预)</p>
</li>
<li><p>当然对于某些特殊的需求，系统的dispatchTouchEvent方法可能不适用，那么需要重写ViewGroup的dispatchTouchEvent方法，那么事件分发的逻辑完全有我们定义。只要ViewGroup能接收到事件，它的dispatchTouchEvent每次都会被调用。</p>
</li>
<li><p>如果ACTION_DOWN事件发生在某个View的范围之内，则后续的ACTION_MOVE，ACTION_UP和ACTION_CANCEL等事件都将被发往该View，即使事件已经出界了。</p>
</li>
<li><p>第一根按下的手指触发ACTION_DOWN事件，之后按下的手指触发ACTION_POINTER_DOWN事件，中间起来的手指触发ACTION_POINTER_UP事件，最后起来的手指触发ACTION_UP事件（即使它不是触发ACTION_DOWN事件的那根手指）。</p>
</li>
<li><p>pointer id可以用于跟踪手指，从按下的那个时刻起pointer id生效，直至起来的那一刻失效，这之间维持不变（后续MotionEvent会详细解读）。</p>
</li>
<li><p>如果父View在onInterceptTouchEvent中拦截了事件，则onInterceptTouchEvent中不会再收到Touch事件了，事件被直接交给它自己处理（按照普通View的处理方式）。</p>
</li>
<li><p>如果一个事件首先由子view处理，但是如果子view在处理的过程中某个时刻返回了false，则此事件序列全部交给Activity处理。</p>
</li>
</ol>
<h2 id="关于事件分发中的滑动冲突"><a href="#关于事件分发中的滑动冲突" class="headerlink" title="关于事件分发中的滑动冲突"></a>关于事件分发中的滑动冲突</h2><p>常见的滑动冲突场景：</p>
<ul>
<li>1，外部滑动方向与内部滑动方向不一致</li>
<li>2，内部滑动方向与外部滑动方向一致</li>
<li>3，上述两种情况的嵌套</li>
</ul>
<p>####滑动冲突场景：</p>
<p>场景1：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="img/008_左右上下冲突.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>类似ViewPager与多个ListFragemnt嵌套</p>
<p>场景2：</p>
<p><img src="img/008_同向冲突.png" alt=""></p>
<p>类似ViewPager与ViewPager的嵌套</p>
<p>场景3：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="img/008_复杂冲突.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>类似SlidMenu加ViewPager加ListFragment</p>
<p>###解决滑动冲突的规则</p>
<ul>
<li><p>对于场景1有以下方法来解决</p>
<ul>
<li>判断滑动路径与水平方向夹角</li>
<li>判断水平方向与垂直方向的距离差(常用)</li>
<li>判断水平方向与垂直方向的速度差</li>
</ul>
</li>
<li><p>对于场景2</p>
<ul>
<li>这能通过业务需求来解决，比如某个情况只允许哪个View滑动</li>
</ul>
</li>
</ul>
<h1 id="关于动画一些内容-下次用的时候可以直接从这里copy代码"><a href="#关于动画一些内容-下次用的时候可以直接从这里copy代码" class="headerlink" title="关于动画一些内容(下次用的时候可以直接从这里copy代码)"></a>关于动画一些内容(下次用的时候可以直接从这里copy代码)</h1><ul>
<li><p>贝塞尔以及其它类型动画的一些总结  </p>
<p>  <a href="&quot;http://www.jianshu.com/p/420da0f6e279&quot;">各种常用动画效果的汇总</a>  </p>
</li>
<li><p>AnimationSet  </p>
<p>  多个动画的组合  </p>
<pre><code>AnimationSet as = new AnimationSet(true);
</code></pre></li>
<li><p>ScaleAnimation  </p>
<p>  变大变小动画</p>
<pre><code>ScaleAnimation sa = new ScaleAnimation(1f, 1.5f, 1f, 1.5f, ScaleAnimation.RELATIVE_TO_SELF,
        0.5f, ScaleAnimation.RELATIVE_TO_SELF, 0.5f);
sa.setDuration(ANIMATIONEACHOFFSET * 3);
sa.setRepeatCount(10);// 设置循环
</code></pre></li>
<li><p>AlphaAnimation  </p>
<p>  透明度动画  </p>
<pre><code>AlphaAnimation aniAlp = new AlphaAnimation(1, 0.1f);
aniAlp.setRepeatCount(10);// 设置循环
as.setDuration(ANIMATIONEACHOFFSET * 3);
</code></pre><p>  最后用一个addAnimation讲动画加进这个控件中  </p>
<pre><code>as.addAnimation(sa);
as.addAnimation(aniAlp);
</code></pre><p>  开始一个动画labelicon是一个view  </p>
<pre><code>labelIcon.startAnimation(as);
</code></pre></li>
<li>怎么让多个组合动画重复执行？<br>stackoverflow：<br><a href="&quot;http://stackoverflow.com/questions/17622333/repeat-animatorset&quot;">第二个回答，给animatorset加一个监听器</a>   </li>
</ul>
<p>示例：  </p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; 
&lt;!--First Stage  --&gt;
&lt;set  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;   
  android:ordering=&quot;together&quot;&gt;  
    &lt;objectAnimator 
        android:valueType=&quot;floatType&quot;
        android:duration=&quot;500&quot;
        android:propertyName=&quot;alpha&quot;
        android:valueFrom=&quot;1&quot;
        android:valueTo=&quot;0.8&quot;
        &gt;
    &lt;/objectAnimator&gt;

    &lt;objectAnimator 
        android:valueType=&quot;floatType&quot;
        android:duration=&quot;500&quot;
        android:propertyName=&quot;scaleX&quot;
        android:valueFrom=&quot;1&quot;
        android:valueTo=&quot;0.8&quot;
        &gt;
    &lt;/objectAnimator&gt;

    &lt;objectAnimator 
        android:valueType=&quot;floatType&quot;
        android:duration=&quot;500&quot;
        android:propertyName=&quot;scaleY&quot;
        android:valueFrom=&quot;1&quot;
        android:valueTo=&quot;0.8&quot;
        &gt;
    &lt;/objectAnimator&gt;

    &lt;objectAnimator
        android:propertyName=&quot;x&quot;
        android:duration=&quot;500&quot;
        android:valueFrom=&quot;0&quot;
        android:valueTo=&quot;20&quot;
        &gt;
    &lt;/objectAnimator&gt;

    &lt;objectAnimator
        android:propertyName=&quot;y&quot;
        android:duration=&quot;500&quot;
        android:valueFrom=&quot;0&quot;
        android:valueTo=&quot;-20&quot;
        &gt;
    &lt;/objectAnimator&gt;



    &lt;!--Second Stage  --&gt;
    &lt;objectAnimator 
        android:valueType=&quot;floatType&quot;
        android:startOffset=&quot;500&quot;
        android:duration=&quot;500&quot;
        android:propertyName=&quot;alpha&quot;
        android:valueFrom=&quot;0.8&quot;
        android:valueTo=&quot;0.65&quot;
        &gt;
    &lt;/objectAnimator&gt;

    &lt;objectAnimator 
        android:startOffset=&quot;500&quot;
        android:valueType=&quot;floatType&quot;
        android:duration=&quot;500&quot;
        android:propertyName=&quot;scaleX&quot;
        android:valueFrom=&quot;0.8&quot;
        android:valueTo=&quot;0.65&quot;
        &gt;
    &lt;/objectAnimator&gt;

    &lt;objectAnimator 
        android:startOffset=&quot;500&quot;
        android:valueType=&quot;floatType&quot;
        android:duration=&quot;500&quot;
        android:propertyName=&quot;scaleY&quot;
        android:valueFrom=&quot;0.8&quot;
        android:valueTo=&quot;0.65&quot;
        &gt;
    &lt;/objectAnimator&gt;

    &lt;objectAnimator
        android:startOffset=&quot;500&quot;
        android:propertyName=&quot;x&quot;
        android:duration=&quot;500&quot;
        android:valueFrom=&quot;20&quot;
        android:valueTo=&quot;-20&quot;
        &gt;
    &lt;/objectAnimator&gt;

    &lt;!--Third Stage  --&gt;
    &lt;objectAnimator 
        android:startOffset=&quot;1000&quot;
        android:valueType=&quot;floatType&quot;
        android:duration=&quot;500&quot;
        android:propertyName=&quot;alpha&quot;
        android:valueFrom=&quot;0.65&quot;
        android:valueTo=&quot;1&quot;
        &gt;
    &lt;/objectAnimator&gt;

    &lt;objectAnimator 
        android:startOffset=&quot;1000&quot;
        android:valueType=&quot;floatType&quot;
        android:duration=&quot;500&quot;
        android:propertyName=&quot;scaleX&quot;
        android:valueFrom=&quot;0.65&quot;
        android:valueTo=&quot;1&quot;
        &gt;
    &lt;/objectAnimator&gt;

    &lt;objectAnimator 
        android:startOffset=&quot;1000&quot;
        android:valueType=&quot;floatType&quot;
        android:duration=&quot;500&quot;
        android:propertyName=&quot;scaleY&quot;
        android:valueFrom=&quot;0.65&quot;
        android:valueTo=&quot;1&quot;
        &gt;
    &lt;/objectAnimator&gt;

    &lt;objectAnimator
        android:startOffset=&quot;1000&quot;
        android:propertyName=&quot;x&quot;
        android:duration=&quot;500&quot;
        android:valueFrom=&quot;-20&quot;
        android:valueTo=&quot;0&quot;
        &gt;
    &lt;/objectAnimator&gt;

    &lt;objectAnimator
        android:startOffset=&quot;1000&quot;
        android:propertyName=&quot;y&quot;
        android:duration=&quot;500&quot;
        android:valueFrom=&quot;-20&quot;
        android:valueTo=&quot;0&quot;
        &gt;
    &lt;/objectAnimator&gt;
&lt;/set&gt;
</code></pre><p>android代码部分：  </p>
<pre><code>AnimatorSet animator =    (AnimatorSet) AnimatorInflater.loadAnimator(this,
            R.animator.clock_rotate);
    animator.setTarget(mFloatingImageView);
    animator.addListener(new AnimatorListener() {
        @Override
        public void onAnimationStart(Animator animation) {
            // TODO Auto-generated method stub
            mCanceled = false;
        }

        @Override
        public void onAnimationRepeat(Animator animation) {
            // TODO Auto-generated method stub

        }

        @Override
        public void onAnimationEnd(Animator animation) {
            // TODO Auto-generated method stub
            if (!mCanceled) {
                animation.start();
              }
        }

        @Override
        public void onAnimationCancel(Animator animation) {
            // TODO Auto-generated method stub
            mCanceled = true;
        }
    });
    animator.start();
</code></pre><h1 id="Android-Splash秒开以及Activity白屏，黑屏的原因和过程"><a href="#Android-Splash秒开以及Activity白屏，黑屏的原因和过程" class="headerlink" title="Android Splash秒开以及Activity白屏，黑屏的原因和过程"></a>Android Splash秒开以及Activity白屏，黑屏的原因和过程</h1><ul>
<li><a href="&quot;http://blog.csdn.net/yanzhenjie1003/article/details/52201896&quot;"> Android Splash页秒开</a> </li>
</ul>
<p>MultiDex的简要原理   </p>
<pre><code>我们以APK中有两个dex文件为例，第二个dex文件为classes2.dex。  
兼容包在Applicaion实例化之后，会检查系统版本是否支持 multidex，classes2.dex是否需要安装。  
如果需要安装则会从APK中解压出classes2.dex并将其拷贝到应用的沙盒目录下。  
通过反射将classes2.dex注入到当前的classloader中。  
</code></pre><p>美团的解决方案(推荐后两篇文章)  </p>
<ul>
<li><a href="&quot;http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=207151651&amp;idx=1&amp;sn=9eab282711f4eb2b4daf2fbae5a5ca9a&amp;3rd=MzA3MDU4NTYzMw==&amp;scene=6#rd&quot;"> Android拆分与加载Dex的多种方案对比(手机QQ，微信)</a> </li>
</ul>
<p>手机QQ，微信的解决方案  </p>
<ul>
<li><a href="&quot;http://tech.meituan.com/mt-android-auto-split-dex.html&quot;"> 美团Android DEX自动拆包及动态加载简介 </a>  </li>
</ul>
<p>综合解决方案  </p>
<ul>
<li><a href="&quot;http://blog.zongwu233.com/the-touble-of-multidex&quot;"> 其实你不知道MultiDex到底有多坑 </a>  </li>
</ul>
<h1 id="9-使用multidex时会出现的一些坑点，以及解决方式和部署步骤"><a href="#9-使用multidex时会出现的一些坑点，以及解决方式和部署步骤" class="headerlink" title="9 使用multidex时会出现的一些坑点，以及解决方式和部署步骤"></a>9 使用multidex时会出现的一些坑点，以及解决方式和部署步骤</h1><p>汇集解决所有办法的关键文章与插件 </p>
<ul>
<li><a href="&quot;https://github.com/TangXiaoLv/Android-Easy-MultiDex&quot;">Android傻瓜式分包插件</a> </li>
</ul>
<p>MultiDex的简要原理   </p>
<p>我们以APK中有两个dex文件为例，第二个dex文件为classes2.dex。<br>    兼容包在Applicaion实例化之后，会检查系统版本是否支持 multidex，classes2.dex是否需要安装。<br>    如果需要安装则会从APK中解压出classes2.dex并将其拷贝到应用的沙盒目录下。<br>    通过反射将classes2.dex注入到当前的classloader中。  </p>
<p>Android Dex 分包并根据multidex源码解析(热修复的基础)  </p>
<ul>
<li><a href="&quot;http://souly.cn/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/2016/02/25/android%E5%88%86%E5%8C%85%E5%8E%9F%E7%90%86/&quot;"> 少量multidex源码解析</a> </li>
</ul>
<p>Android Dex 分包指南  </p>
<ul>
<li><a href="&quot;http://www.jianshu.com/p/b38124d332be&quot;"> Android Dex 分包指南</a> </li>
</ul>
<p>手机QQ，微信的解决方案  </p>
<ul>
<li><a href="&quot;http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=207151651&amp;idx=1&amp;sn=9eab282711f4eb2b4daf2fbae5a5ca9a&amp;3rd=MzA3MDU4NTYzMw==&amp;scene=6#rd&quot;"> Android拆分与加载Dex的多种方案对比(手机QQ，微信)</a> </li>
</ul>
<p>美团的解决方案(推荐后两篇文章)  </p>
<ul>
<li><a href="&quot;http://tech.meituan.com/mt-android-auto-split-dex.html&quot;"> 美团Android DEX自动拆包及动态加载简介 </a>  </li>
</ul>
<p>综合解决方案  </p>
<ul>
<li><a href="&quot;http://blog.zongwu233.com/the-touble-of-multidex&quot;"> 其实你不知道MultiDex到底有多坑 </a>  </li>
</ul>
<h1 id="微信Tinker热修复原理"><a href="#微信Tinker热修复原理" class="headerlink" title="微信Tinker热修复原理"></a>微信Tinker热修复原理</h1><ul>
<li>热修复基本原理</li>
</ul>
<ul>
<li><a href="&quot;https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&amp;mid=400118620&amp;idx=1&amp;sn=b4fdd5055731290eef12ad0d17f39d4a&quot;">Android热修复原理(简单易懂)</a> </li>
</ul>
<ul>
<li>dex包全量替换的原理<br>为什么是65536个方法，因为short只能表示65536个方法，具体计算，short两个字节代表16位，16位就是2的16次方。</li>
<li>dex包全量替换的原理<br>因为这里他不能将新的dex直接加入补丁包中，这样会导致包大小太大，所以，这里他将差异包加入补丁包中(对比两个dex的差异)再将旧的dex和之前用bsdiff算法生成的差异对比后，形成一个新的dex，最后再解析出来，这样的话就很好的解决了这个问题。    </li>
</ul>
<ul>
<li><a href="&quot;https://www.qcloud.com/community/article/101&quot;">完整的方案以及tinker的原理</a> </li>
<li><a href="&quot;http://www.w2bc.com/article/179241&quot;">tinker源码分析</a> </li>
<li><a href="&quot;http://sparkinlee.github.io/2016/08/dex%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%8F%8Adexdiff%E5%8E%9F%E7%90%86&quot;">dex文件格式及dexdiff原理</a>  </li>
<li><a href="&quot;http://dev.qq.com/topic/57ad7a70eaed47bb2699e68e&quot;">微信热补丁 Tinker 的实践演进之路</a> </li>
<li><a href="&quot;https://github.com/dogriffiths/HeadFirstAndroid/wiki/How-Android-Apps-are-Built-and-Run#put-classesdex-and-resources-into-a-package-file&quot;">和android app运行过程相关(how apps built and run)</a> </li>
</ul>
<h1 id="一个Android-Studio上的实用工具"><a href="#一个Android-Studio上的实用工具" class="headerlink" title="一个Android Studio上的实用工具"></a>一个Android Studio上的实用工具</h1><p>这个工具是用来加入不同分辨率图片的工具  </p>
<ul>
<li><a href="&quot;http://blog.inet198.cn/?ziwang_/article/details/51713623&quot;"> Android Drawable Importer的使用 </a>  </li>
</ul>
<p>这个工具是用来统计类里面方法数  </p>
<ul>
<li><a href="&quot;http://inloop.github.io/apk-method-count/&quot;"> APK method count的使用 </a>  </li>
</ul>
<h1 id="gradle一些有用的学习资料"><a href="#gradle一些有用的学习资料" class="headerlink" title="gradle一些有用的学习资料"></a>gradle一些有用的学习资料</h1><ul>
<li><p><a href="&quot;http://blog.csdn.net/sbsujjbcy/article/details/50782830&quot;"> 如何编写一个gradle插件 </a>  </p>
</li>
<li><p><a href="&quot;http://yifeng.studio/2016/09/06/apk-environment-separate&quot;"> gradle实现环境分离 </a>  </p>
</li>
<li><p><a href="&quot;http://www.infoq.com/cn/articles/android-in-depth-gradle&quot;"> 深入理解Android（一）：Gradle详解 </a>  </p>
</li>
</ul>
<h1 id="google上android的mvp结构基本实现方式以及如何规范的运用"><a href="#google上android的mvp结构基本实现方式以及如何规范的运用" class="headerlink" title="google上android的mvp结构基本实现方式以及如何规范的运用"></a>google上android的mvp结构基本实现方式以及如何规范的运用</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;View学习中的一些难点记录&quot;&gt;&lt;a href=&quot;#View学习中的一些难点记录&quot; class=&quot;headerlink&quot; title=&quot;View学习中的一些难点记录&quot;&gt;&lt;/a&gt;View学习中的一些难点记录&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;what is the diff
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
</feed>
