<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SmallBlueWhale&#39;s blog</title>
  <subtitle>Real Life</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://smallbluewhale.github.io/"/>
  <updated>2017-06-09T08:23:03.602Z</updated>
  <id>https://smallbluewhale.github.io/</id>
  
  <author>
    <name>SmallBlueWhale</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android开发系列：“从零搭建一个mvp+retrofit+glide+rxjava+material design的应用”(一)</title>
    <link href="https://smallbluewhale.github.io/2017/06/20/Android%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%9A%E2%80%9C%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAmvp+retrofit+glide+rxjava+material%20design%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%9D(%E4%B8%89)%20/"/>
    <id>https://smallbluewhale.github.io/2017/06/20/Android开发系列：“从零搭建一个mvp+retrofit+glide+rxjava+material design的应用”(三) /</id>
    <published>2017-06-20T03:23:00.000Z</published>
    <updated>2017-06-09T08:23:03.602Z</updated>
    
    <content type="html"><![CDATA[<h2 id="封装一个网络框架-Rxjava-Retrofit-2"><a href="#封装一个网络框架-Rxjava-Retrofit-2" class="headerlink" title="封装一个网络框架(Rxjava + Retrofit 2 +  )"></a>封装一个网络框架(Rxjava + Retrofit 2 +  )</h2><p><img src="http://oa5504rxk.bkt.clouddn.com/week5_MVP/2.jpg" alt="img"></p>
<h2 id="项目分包："><a href="#项目分包：" class="headerlink" title="项目分包："></a>项目分包：</h2><p>为了让项目更加清晰</p>
<p>api：负责网络服务，例如定义网络接口，以及固定常量。</p>
<p>app：项目单独的application</p>
<p>bean：负责实体类的定义</p>
<p>db：负责view和接口层</p>
<p>ui：整个mvp中最关键的一环，每一个功能模块在这内部都应分出一个属于自己的包。这内部中有几个功能模块，比如main，main模块是总组成，又可以分成activity，fragment，contract，model，presenter。其中activity和fragment属于view，contract定义了这个view和model以及presenter全部的功能接口，属于一个能让结构更加清晰的类，每次分析项目，只需要从contract看起就可以清楚的理解这个模块主要承载了什么样子的功能特点。同时，我们构建项目也只需要先从contract入手，这样就不会在mvp这个架构中被一堆的接口绕晕。model层定义的是数据类型，用来拼装一系列数据，将数据拼装好再传到presenter中通过Presenter层接口进行调用。</p>
<p>util：负责项目一些公有的项目大部分功能。</p>
<p>widget：项目中的自定义控件</p>
<p>部分参考自：</p>
<p><a href="https://yuanjunli.github.io/2016/11/26/rxjava+retrofit+OkHttp%E5%B0%81%E8%A3%85/" target="_blank" rel="external">RxJava+Retrofit+OkHttp封装</a></p>
<p><a href="http://blog.csdn.net/column/details/13297.html" target="_blank" rel="external">Android RxJava之网络处理专栏</a></p>
<p># </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;封装一个网络框架-Rxjava-Retrofit-2&quot;&gt;&lt;a href=&quot;#封装一个网络框架-Rxjava-Retrofit-2&quot; class=&quot;headerlink&quot; title=&quot;封装一个网络框架(Rxjava + Retrofit 2 +  )&quot;&gt;&lt;/a&gt;封
    
    </summary>
    
    
      <category term="Android" scheme="https://smallbluewhale.github.io/tags/Android/"/>
    
      <category term="MVP" scheme="https://smallbluewhale.github.io/tags/MVP/"/>
    
      <category term="Retrofit" scheme="https://smallbluewhale.github.io/tags/Retrofit/"/>
    
      <category term="Rxjava" scheme="https://smallbluewhale.github.io/tags/Rxjava/"/>
    
      <category term="Material Design" scheme="https://smallbluewhale.github.io/tags/Material-Design/"/>
    
      <category term="Glide" scheme="https://smallbluewhale.github.io/tags/Glide/"/>
    
      <category term="Gradle" scheme="https://smallbluewhale.github.io/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>Android常见内存泄漏原因以及解决方法</title>
    <link href="https://smallbluewhale.github.io/2017/06/09/Android%E5%B8%B8%E8%A7%81%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%8E%9F%E5%9B%A0%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://smallbluewhale.github.io/2017/06/09/Android常见内存泄漏原因以及解决方法/</id>
    <published>2017-06-09T03:23:00.000Z</published>
    <updated>2017-06-09T07:37:25.456Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h1><p><strong>Handler出现内存泄漏的原因，handler内部持有了一个context对象，同时如果这个对象因为handler消息未发送完成导致context对象一直无法被销毁，出现内存泄漏，同时如果我们新开一个线程去发送消息的话，也会因此出现内存泄漏。如下：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">    </div><div class="line">  &#125;</div><div class="line">&#125;).start();</div></pre></td></tr></table></figure>
<p><strong>Runnable是一个匿名内部类，会隐含的持有外部类对象，具体原因下面</strong></p>
<h1 id="Non-static-Inner-Class"><a href="#Non-static-Inner-Class" class="headerlink" title="Non-static Inner Class"></a>Non-static Inner Class</h1><p><strong>非静态匿名内部类导致的内存泄漏问题，主要是因为非静态匿名内部类是属于外部类的一部分，所以如果这个匿名内部类的周期比外部类的周期要长的话，它会隐式引用这个外部类，同时这个外部类就因为被持有，导致无法销毁，因此就泄漏了。</strong></p>
<p><a href="http://www.androiddesignpatterns.com/2013/01/inner-class-handler-memory-leak.html" target="_blank" rel="external"> 内存泄漏之Handler &amp; InnerClass</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Handler&quot;&gt;&lt;a href=&quot;#Handler&quot; class=&quot;headerlink&quot; title=&quot;Handler&quot;&gt;&lt;/a&gt;Handler&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Handler出现内存泄漏的原因，handler内部持有了一个context对象，同
    
    </summary>
    
    
      <category term="Android" scheme="https://smallbluewhale.github.io/tags/Android/"/>
    
      <category term="Context" scheme="https://smallbluewhale.github.io/tags/Context/"/>
    
      <category term="Handler &amp;&amp; InnerClass" scheme="https://smallbluewhale.github.io/tags/Handler-InnerClass/"/>
    
      <category term="Memory Leak" scheme="https://smallbluewhale.github.io/tags/Memory-Leak/"/>
    
      <category term="Static" scheme="https://smallbluewhale.github.io/tags/Static/"/>
    
  </entry>
  
  <entry>
    <title>Android TTF格式字体提取(避免添加整个字体包)</title>
    <link href="https://smallbluewhale.github.io/2017/06/03/Android%20ttf%E5%AD%97%E4%BD%93%E6%8F%90%E5%8F%96/"/>
    <id>https://smallbluewhale.github.io/2017/06/03/Android ttf字体提取/</id>
    <published>2017-06-03T03:23:00.000Z</published>
    <updated>2017-06-09T07:34:51.421Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ttf字体提取"><a href="#ttf字体提取" class="headerlink" title="ttf字体提取"></a>ttf字体提取</h1><p><strong>Android或则其它地方需要用到一些特殊字体，然后字体库都是几兆的大小，全部导入会导致包的大小激增，如何解决这个问题？</strong></p>
<ul>
<li>首先，安装sfnttool字体提取工具并集成java环境(废话)</li>
<li>命令行到sfnttool目录下，输入java -jar sfnttool.jar  -s ‘字符提取’ test.ttf test_exact.ttf  </li>
<li>字符文件就被提取到同目录下的test_exact.ttf中</li>
</ul>
<h1 id="ttf在Android-Studio的应用"><a href="#ttf在Android-Studio的应用" class="headerlink" title="ttf在Android Studio的应用"></a>ttf在Android Studio的应用</h1><ul>
<li>Android studio project的assets目录下有一个fonts目录,没有的话就新建一个fonts目录并且将ttf文件导入到fonts目录下。</li>
<li><p>可以开始在代码中使用，如下所示：</p>
<p><strong>TextView tv = getTextView();<br>Typeface typeface = Typeface.createFromAsset(getAssets(),”fonts/bluewhale.ttf”);<br>tv.setTypeface(tupeface);</strong></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ttf字体提取&quot;&gt;&lt;a href=&quot;#ttf字体提取&quot; class=&quot;headerlink&quot; title=&quot;ttf字体提取&quot;&gt;&lt;/a&gt;ttf字体提取&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Android或则其它地方需要用到一些特殊字体，然后字体库都是几兆的大小，全部导入会
    
    </summary>
    
    
      <category term="Android" scheme="https://smallbluewhale.github.io/tags/Android/"/>
    
      <category term="TTF" scheme="https://smallbluewhale.github.io/tags/TTF/"/>
    
      <category term="font" scheme="https://smallbluewhale.github.io/tags/font/"/>
    
  </entry>
  
  <entry>
    <title>Android环境分离(分离测试和正式环境)</title>
    <link href="https://smallbluewhale.github.io/2017/04/11/Android%E7%8E%AF%E5%A2%83%E5%88%86%E7%A6%BB(%E5%88%86%E7%A6%BB%E6%B5%8B%E8%AF%95%E5%92%8C%E6%AD%A3%E5%BC%8F%E7%8E%AF%E5%A2%83)/"/>
    <id>https://smallbluewhale.github.io/2017/04/11/Android环境分离(分离测试和正式环境)/</id>
    <published>2017-04-11T03:23:00.000Z</published>
    <updated>2017-04-13T01:45:41.809Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android环境分离"><a href="#Android环境分离" class="headerlink" title="Android环境分离"></a>Android环境分离</h1><p><strong>昨天项目写了个bug,这里原因其实是测试环境以及正式环境总是变换导致各种第三方id以及url在测试中忘记改回来，然后我觉得人总是没有机器智能的，因此代码的控制对我们程序员还是很有必要的，在这里记录一下Android的环境分离，下一次就不会因为忘记改回来出现bug了。</strong></p>
<h3 id="Build-Variants"><a href="#Build-Variants" class="headerlink" title="Build Variants"></a>Build Variants</h3><h4 id="Product-flavors"><a href="#Product-flavors" class="headerlink" title="Product flavors"></a>Product flavors</h4><p>1.可以用视图去控制(和你在gradle中使用代码控制是一样的)</p>
<p>首先第一种方式，用flavors去控制环境分离</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android环境分离&quot;&gt;&lt;a href=&quot;#Android环境分离&quot; class=&quot;headerlink&quot; title=&quot;Android环境分离&quot;&gt;&lt;/a&gt;Android环境分离&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;昨天项目写了个bug,这里原因其实是测试环境以及正式
    
    </summary>
    
    
      <category term="Android" scheme="https://smallbluewhale.github.io/tags/Android/"/>
    
      <category term="gradle" scheme="https://smallbluewhale.github.io/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>Android开发系列：“从零搭建一个mvp+retrofit+glide+rxjava+material design的应用”(二)</title>
    <link href="https://smallbluewhale.github.io/2017/04/01/Android%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%9A%E2%80%9C%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAmvp+retrofit+glide+rxjava+material%20design%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%9D(%E4%BA%8C)/"/>
    <id>https://smallbluewhale.github.io/2017/04/01/Android开发系列：“从零搭建一个mvp+retrofit+glide+rxjava+material design的应用”(二)/</id>
    <published>2017-04-01T03:23:00.000Z</published>
    <updated>2017-06-09T03:23:04.238Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rxjava生命周期管理"><a href="#Rxjava生命周期管理" class="headerlink" title="Rxjava生命周期管理"></a>Rxjava生命周期管理</h1><p>对于这个大量运用mvp,rxjava的项目，我们很容易出现内存泄漏的问题，因此需要一个统一管理rxjava生命周期的类。命名为rxmanager。</p>
<p>这里我们可以使用compositeSubscription这个类的unsubscribe方法来管理生命周期。</p>
<h2 id="RxManager"><a href="#RxManager" class="headerlink" title="RxManager"></a>RxManager</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.hyx.whale.whalenote.base;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.HashMap;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"></div><div class="line"><span class="keyword">import</span> rx.Observable;</div><div class="line"><span class="keyword">import</span> rx.Subscription;</div><div class="line"><span class="keyword">import</span> rx.android.schedulers.AndroidSchedulers;</div><div class="line"><span class="keyword">import</span> rx.functions.Action;</div><div class="line"><span class="keyword">import</span> rx.functions.Action1;</div><div class="line"><span class="keyword">import</span> rx.subscriptions.CompositeSubscription;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * funtion :用于管理单个presenter的rxbus事件和rxjava相关代码的生命周期处理。</div><div class="line"> * author  :smallbluewhale.</div><div class="line"> * date    :2017/4/5 0005.</div><div class="line"> * version :1.0.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RxManager</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> RxBus mRxbus = RxBus.getInstance();</div><div class="line">    <span class="comment">/*</span></div><div class="line">    * 管理Observable和Subscribe订阅</div><div class="line">    * 取消以及注册订阅</div><div class="line">    * */</div><div class="line">    <span class="keyword">private</span> CompositeSubscription compositeSubscription = <span class="keyword">new</span> CompositeSubscription();</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">    * 单纯的obserables和subscribers管理</div><div class="line">    * */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Subscription subscription)</span></span>&#123;</div><div class="line">        <span class="comment">/*订阅管理*/</span></div><div class="line">        compositeSubscription.add(subscription);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 单个presenter生命周期结束，取消订阅和所有rxbus观察</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</div><div class="line">        compositeSubscription.unsubscribe();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="RxBus"><a href="#RxBus" class="headerlink" title="RxBus"></a>RxBus</h2><p><strong>另外我觉得一个项目免不了事件传递和事件发送，因此我们可以利用rxjava来编写一个类似eventbus的事件处理类，代码很简洁，也很简单，相应的注释都写在类的头部</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.hyx.whale.whalenote.base;</div><div class="line"></div><div class="line"><span class="keyword">import</span> android.support.annotation.NonNull;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.Collection;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</div><div class="line"></div><div class="line"><span class="keyword">import</span> rx.Observable;</div><div class="line"><span class="keyword">import</span> rx.android.schedulers.AndroidSchedulers;</div><div class="line"><span class="keyword">import</span> rx.functions.Action;</div><div class="line"><span class="keyword">import</span> rx.functions.Action1;</div><div class="line"><span class="keyword">import</span> rx.subjects.PublishSubject;</div><div class="line"><span class="keyword">import</span> rx.subjects.Subject;</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> android.R.attr.tag;</div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> android.R.string.no;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * funtion :用rxbus和rxandroid实现的一个事件监听的类</div><div class="line"> * author  :smallbluewhale.</div><div class="line"> * date    :2017/3/21 0021.</div><div class="line"> * version :1.0.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RxBus</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RxBus instance;</div><div class="line"></div><div class="line"></div><div class="line">    RxBus()&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RxBus <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">null</span>==instance)&#123;</div><div class="line">            <span class="keyword">synchronized</span> (RxBus.class)&#123;</div><div class="line">                instance = <span class="keyword">new</span> RxBus();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>  instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">//每一种tag类型有一个同种类型事件的lsit</span></div><div class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;Object , List&lt;Subject&gt;&gt; subjectMapper = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 订阅事件源</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> mObservable</div><div class="line">     * <span class="doctag">@param</span> mAction1</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> RxBus <span class="title">onEvent</span><span class="params">(Observable&lt;?&gt; mObservable , Action1&lt;Object&gt; mAction1)</span></span>&#123;</div><div class="line">        mObservable.observeOn(AndroidSchedulers.mainThread()).subscribe(mAction1, <span class="keyword">new</span> Action1&lt;Throwable&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Throwable throwable)</span> </span>&#123;</div><div class="line">                throwable.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">return</span> getInstance();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 注册事件源</div><div class="line">     * 1.将事件按照tag标志放置在一个map中，然后不同tag事件对应不同一个subjectlist</div><div class="line">     * 2.再创建一个tag对应的subject放在</div><div class="line">     * <span class="doctag">@param</span> tag</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">register</span><span class="params">(@NonNull Object tag)</span></span>&#123;</div><div class="line">        List&lt;Subject&gt; subjectList = subjectMapper.get(tag);</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == subjectList)&#123;</div><div class="line">            subjectList = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            subjectMapper.put(tag,subjectList);</div><div class="line">        &#125;</div><div class="line">        Subject&lt;T,T&gt; subject = PublishSubject.create();</div><div class="line">        subjectList.add(subject);</div><div class="line">        <span class="keyword">return</span> subject;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">    * 简单发送事件</div><div class="line">    * 默认设置content的类名为tag标志</div><div class="line">    * */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(@NonNull Object content)</span></span>&#123;</div><div class="line">        post(content.getClass().getName(),content);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 触发事件</div><div class="line">     * 遍历全部相同tag事件的list，然后将相同的时间全部post出去，利用subject的一些有用的特性，例如可以构造一个无发送事件的observable</div><div class="line">     * <span class="doctag">@param</span> content</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(@NonNull Object tag,@NonNull Object content)</span></span>&#123;</div><div class="line">        List&lt;Subject&gt; subjectList = subjectMapper.get(tag);</div><div class="line">        <span class="keyword">if</span>(!isEmpty(subjectList))&#123;</div><div class="line">            <span class="keyword">for</span> (Subject subject :</div><div class="line">                    subjectList) &#123;</div><div class="line">                subject.onNext(content);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 解绑事件</div><div class="line">     * <span class="doctag">@param</span> content</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unRegister</span><span class="params">(@NonNull Object content)</span></span>&#123;</div><div class="line">        List&lt;Subject&gt; subjectList = subjectMapper.get(content);</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != subjectList)&#123;</div><div class="line">            subjectMapper.remove(content);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 取消监听</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> tag</div><div class="line">     * <span class="doctag">@param</span> observable</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> RxBus <span class="title">unRegister</span><span class="params">(@NonNull Object tag , @NonNull Observable&lt;?&gt;observable)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == observable)&#123;</div><div class="line">            getInstance();</div><div class="line">        &#125;</div><div class="line">        List&lt;Subject&gt; subjectList = subjectMapper.get(tag);</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != subjectList)&#123;</div><div class="line">            subjectList.remove((Subject&lt;?,?&gt;)observable);</div><div class="line">            <span class="keyword">if</span>(isEmpty(subjectList))&#123;</div><div class="line">                subjectMapper.remove(tag);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> getInstance();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">(Collection&lt;Subject&gt; collection)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span> == collection || collection.isEmpty();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，我们可以用rxmanager再统一处理rxbus。建立一个map存储</p>
<p># </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Rxjava生命周期管理&quot;&gt;&lt;a href=&quot;#Rxjava生命周期管理&quot; class=&quot;headerlink&quot; title=&quot;Rxjava生命周期管理&quot;&gt;&lt;/a&gt;Rxjava生命周期管理&lt;/h1&gt;&lt;p&gt;对于这个大量运用mvp,rxjava的项目，我们很容易出现内
    
    </summary>
    
    
      <category term="Android" scheme="https://smallbluewhale.github.io/tags/Android/"/>
    
      <category term="MVP" scheme="https://smallbluewhale.github.io/tags/MVP/"/>
    
      <category term="Retrofit" scheme="https://smallbluewhale.github.io/tags/Retrofit/"/>
    
      <category term="Rxjava" scheme="https://smallbluewhale.github.io/tags/Rxjava/"/>
    
      <category term="Material Design" scheme="https://smallbluewhale.github.io/tags/Material-Design/"/>
    
      <category term="Glide" scheme="https://smallbluewhale.github.io/tags/Glide/"/>
    
      <category term="Gradle" scheme="https://smallbluewhale.github.io/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>Android日常开发bug记录</title>
    <link href="https://smallbluewhale.github.io/2017/03/20/Android%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91bug%E8%AE%B0%E5%BD%95/"/>
    <id>https://smallbluewhale.github.io/2017/03/20/Android日常开发bug记录/</id>
    <published>2017-03-20T03:23:00.000Z</published>
    <updated>2017-03-20T09:18:44.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android日常开发bug记录"><a href="#Android日常开发bug记录" class="headerlink" title="Android日常开发bug记录"></a>Android日常开发bug记录</h1><p><strong>1.某些工具类需要用到一个context上下文，为了简便我们可以不用传context变量，这时，Application全局的context为null以及如何正确获取？</strong></p>
<ul>
<li><p>首先设置manifest中设置application:name，设置成你一开始创建的那个application的名字。</p>
</li>
<li><p>然后直接在application中的oncreate方法设置context.</p>
<p>context = getApplicationContext();</p>
<p>return context;</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android日常开发bug记录&quot;&gt;&lt;a href=&quot;#Android日常开发bug记录&quot; class=&quot;headerlink&quot; title=&quot;Android日常开发bug记录&quot;&gt;&lt;/a&gt;Android日常开发bug记录&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1.某些工具
    
    </summary>
    
    
      <category term="Android" scheme="https://smallbluewhale.github.io/tags/Android/"/>
    
      <category term="bug" scheme="https://smallbluewhale.github.io/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>Rxjava学习记录</title>
    <link href="https://smallbluewhale.github.io/2017/03/20/Rxjava%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>https://smallbluewhale.github.io/2017/03/20/Rxjava学习记录/</id>
    <published>2017-03-20T03:23:00.000Z</published>
    <updated>2017-03-22T07:05:29.044Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rxjava学习记录"><a href="#Rxjava学习记录" class="headerlink" title="Rxjava学习记录"></a>Rxjava学习记录</h1><p><strong>map操作符和flatmap操作符其实都是转化用的，区别是</strong></p>
<ul>
<li>map是一个一对一转化.       例：提取一个文件夹下的一张图片，就只要把file转化成bitmap.</li>
<li>flatmap是一对多的操作. 例：提取一个文件夹下的多张图片，这个时候如果不能用flatmap,所以我们用flatmap将file转化成List<bitmap>.</bitmap></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Rxjava学习记录&quot;&gt;&lt;a href=&quot;#Rxjava学习记录&quot; class=&quot;headerlink&quot; title=&quot;Rxjava学习记录&quot;&gt;&lt;/a&gt;Rxjava学习记录&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;map操作符和flatmap操作符其实都是转化用的，区别是&lt;
    
    </summary>
    
    
      <category term="Android" scheme="https://smallbluewhale.github.io/tags/Android/"/>
    
      <category term="Rxjava" scheme="https://smallbluewhale.github.io/tags/Rxjava/"/>
    
  </entry>
  
  <entry>
    <title>Android开发系列：“从零搭建一个mvp+retrofit+glide+rxjava+material design的应用”(一)</title>
    <link href="https://smallbluewhale.github.io/2017/03/08/Android%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%9A%E2%80%9C%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAmvp+retrofit+glide+rxjava+material%20design%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%9D(%E4%B8%80)%20%20-%20%E5%89%AF%E6%9C%AC/"/>
    <id>https://smallbluewhale.github.io/2017/03/08/Android开发系列：“从零搭建一个mvp+retrofit+glide+rxjava+material design的应用”(一)  - 副本/</id>
    <published>2017-03-08T03:23:00.000Z</published>
    <updated>2017-04-12T02:20:43.280Z</updated>
    
    <content type="html"><![CDATA[<h2 id="gradle配置"><a href="#gradle配置" class="headerlink" title="gradle配置"></a>gradle配置</h2><p>首先项目的开始，我们需要先就项目需要用到的第三方库对gradle进行相应的配置。</p>
<p><strong>Material Design(module中)</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">compile <span class="string">'com.android.support:support-v4:23.+'</span></div><div class="line">compile <span class="string">'com.android.support:support-annotations:23.+'</span></div><div class="line">compile <span class="string">'com.android.support:design:23.+'</span></div><div class="line">compile <span class="string">'com.android.support:cardview-v7:23.+'</span></div><div class="line">compile <span class="string">'com.android.support:recyclerview-v7:23.+'</span></div><div class="line">compile <span class="string">'com.android.support:appcompat-v7:23.+'</span></div></pre></td></tr></table></figure>
<p><strong>Retrofit+Rxjava+Glide(module中):</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">compile <span class="string">'com.squareup.retrofit2:retrofit:2.0.0-beta3'</span></div><div class="line">compile <span class="string">'com.squareup.okhttp3:logging-interceptor:3.1.2'</span></div><div class="line">compile <span class="string">'io.reactivex:rxjava:1.0.1'</span></div><div class="line">compile <span class="string">'io.reactivex:rxandroid:1.0.1'</span></div><div class="line">compile <span class="string">'com.squareup.retrofit2:converter-gson:2.0.0-beta4'</span></div><div class="line">compile <span class="string">'com.squareup.retrofit2:adapter-rxjava:2.0.0-beta4'</span></div><div class="line">compile <span class="string">'com.github.bumptech.glide:glide:3.7.0'</span></div></pre></td></tr></table></figure>
<p><strong>Multidex(module中):</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">compile <span class="string">'com.android.support:multidex:1.0.0'</span><span class="comment">//分包</span></div></pre></td></tr></table></figure>
<p><strong>ButterKnife(module中):</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">compile <span class="string">'com.jakewharton:butterknife:7.0.1'</span><span class="comment">//view注解</span></div></pre></td></tr></table></figure>
<p><strong>Freeline*(project中的gradle):</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">classpath <span class="string">'com.antfortune.freeline:gradle:0.8.6</span></div></pre></td></tr></table></figure>
<p><strong>接着在项目的app module中:</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apply <span class="string">plugin:</span> <span class="string">'com.antfortune.freeline'</span></div></pre></td></tr></table></figure>
<p>这个是一个完整的mvp项目该有的样子，可以看到业务业务相关的代码全部被移到了presenter中，activity实现减负。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oa5504rxk.bkt.clouddn.com/week5_MVP/2.jpg" alt="img" title="">
                </div>
                <div class="image-caption">img</div>
            </figure>
<h2 id="项目分包："><a href="#项目分包：" class="headerlink" title="项目分包："></a>项目分包：</h2><p>为了让项目更加清晰</p>
<p>api：负责网络服务，例如定义网络接口，以及固定常量。</p>
<p>app：项目单独的application</p>
<p>bean：负责实体类的定义</p>
<p>db：负责view和接口层</p>
<p>ui：整个mvp中最关键的一环，每一个功能模块在这内部都应分出一个属于自己的包。这内部中有几个功能模块，比如main，main模块是总组成，又可以分成activity，fragment，contract，model，presenter。其中activity和fragment属于view，contract定义了这个view和model以及presenter全部的功能接口，属于一个能让结构更加清晰的类，每次分析项目，只需要从contract看起就可以清楚的理解这个模块主要承载了什么样子的功能特点。同时，我们构建项目也只需要先从contract入手，这样就不会在mvp这个架构中被一堆的接口绕晕。model层定义的是数据类型，用来拼装一系列数据，将数据拼装好再传到presenter中通过Presenter层接口进行调用。</p>
<p>util：负责项目一些公有的项目大部分功能。</p>
<p>widget：项目中的自定义控件</p>
<p>部分参考自google mvp architecture 以及bugly文章</p>
<p><a href="http://dev.qq.com/topic/57bfef673c1174283d60bac0" target="_blank" rel="external">http://dev.qq.com/topic/57bfef673c1174283d60bac0</a></p>
<p><a href="https://github.com/googlesamples/android-architecture/" target="_blank" rel="external">https://github.com/googlesamples/android-architecture/</a></p>
<p># </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;gradle配置&quot;&gt;&lt;a href=&quot;#gradle配置&quot; class=&quot;headerlink&quot; title=&quot;gradle配置&quot;&gt;&lt;/a&gt;gradle配置&lt;/h2&gt;&lt;p&gt;首先项目的开始，我们需要先就项目需要用到的第三方库对gradle进行相应的配置。&lt;/p&gt;
&lt;
    
    </summary>
    
    
      <category term="Android" scheme="https://smallbluewhale.github.io/tags/Android/"/>
    
      <category term="MVP" scheme="https://smallbluewhale.github.io/tags/MVP/"/>
    
      <category term="Retrofit" scheme="https://smallbluewhale.github.io/tags/Retrofit/"/>
    
      <category term="Rxjava" scheme="https://smallbluewhale.github.io/tags/Rxjava/"/>
    
      <category term="Material Design" scheme="https://smallbluewhale.github.io/tags/Material-Design/"/>
    
      <category term="Glide" scheme="https://smallbluewhale.github.io/tags/Glide/"/>
    
      <category term="Gradle" scheme="https://smallbluewhale.github.io/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>Android设计模式(developing)</title>
    <link href="https://smallbluewhale.github.io/2017/02/05/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(developing)/"/>
    <id>https://smallbluewhale.github.io/2017/02/05/Android设计模式(developing)/</id>
    <published>2017-02-05T03:23:00.000Z</published>
    <updated>2017-06-05T09:41:54.445Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android设计模式"><a href="#Android设计模式" class="headerlink" title="Android设计模式"></a>Android设计模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p><strong>大概分成以下这几种实现方式，加锁和未加锁分别有不同的实现方式</strong></p>
<ul>
<li>懒汉式</li>
<li>饿汉式</li>
<li>双重校验锁</li>
<li>静态内部类</li>
</ul>
<p>下面我总结前三种比较常用的设计模式的方式</p>
<h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleInstance</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> SingleInstance singleInstance = <span class="keyword">new</span> SingleInstance();</div><div class="line">  	</div><div class="line">  <span class="function"><span class="keyword">public</span> SingleInstance <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">    	<span class="keyword">return</span> singleInstance;</div><div class="line">  	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>当类的构造中有大量的逻辑操作或其它操作的时候，这个类加载的速度会变得更加慢。</li>
<li>当类只是被实例化不做任何操作的时候，会占用并浪费资源。</li>
</ol>
<h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> <span class="class"><span class="keyword">class</span> <span class="title">SingleInstance</span></span>&#123;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> SingleInstance singleInstance;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">SingleInstance</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleInstance <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">     <span class="keyword">if</span>(<span class="keyword">null</span>==singleInstance)&#123;</div><div class="line">       singleInstance = <span class="keyword">new</span> SingleInstance();</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> singleInstance;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>这种方式去加载的话，类的资源只有第一次加载才需要进行初始化。</li>
</ol>
<p>如果需要同步锁校验的话代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> <span class="class"><span class="keyword">class</span> <span class="title">SingleInstance</span></span>&#123;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> SingleInstance singleInstance;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">SingleInstance</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingleInstance <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">     <span class="keyword">if</span>(<span class="keyword">null</span>==singleInstance)&#123;</div><div class="line">       singleInstance = <span class="keyword">new</span> SingleInstance();</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> singleInstance;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是这种方式相对来说会影响getInstance的效率，不能每一次都对getInstance进行检查。</p>
<p>那么就需要下面这一种</p>
<h3 id="双重校验锁"><a href="#双重校验锁" class="headerlink" title="双重校验锁"></a>双重校验锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleInstance</span></span>&#123;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> SingleInstance singleInstance;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">SingleInstance</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleInstance <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">     <span class="keyword">if</span>(<span class="keyword">null</span>==singleInstance)&#123;</div><div class="line">       <span class="keyword">synchronized</span>(SingleInstance.class)&#123;</div><div class="line">         	<span class="keyword">if</span>(<span class="keyword">null</span>==singleInstance)&#123;</div><div class="line">       			singleInstance = <span class="keyword">new</span> SingleInstance();</div><div class="line">             &#125;</div><div class="line">     	&#125;</div><div class="line">      &#125;</div><div class="line">     <span class="keyword">return</span> singleInstance;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这一种再singleinstance为空的时候才进行校验，解决了每次都要检查同步锁的问题，只有在singleinstance没有进行初始化的时候才进行校验.</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一般情况下我们使用<strong>饿汉式</strong>就可以了，如果构造函数有过多的操作，那么我觉得使用<strong>懒汉式</strong>或则<strong>双重校验锁</strong>会更加合适。</p>
<blockquote>
<p><a href="http://hujiandong.com/2016/12/21/design_pattern_singleton/" target="_blank" rel="external">http://hujiandong.com/2016/12/21/design_pattern_singleton/</a></p>
</blockquote>
<h2 id="Builder模式"><a href="#Builder模式" class="headerlink" title="Builder模式"></a>Builder模式</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android设计模式&quot;&gt;&lt;a href=&quot;#Android设计模式&quot; class=&quot;headerlink&quot; title=&quot;Android设计模式&quot;&gt;&lt;/a&gt;Android设计模式&lt;/h1&gt;&lt;h2 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;
    
    </summary>
    
    
      <category term="Android" scheme="https://smallbluewhale.github.io/tags/Android/"/>
    
      <category term="设计模式" scheme="https://smallbluewhale.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Android部分知识的原理</title>
    <link href="https://smallbluewhale.github.io/2016/12/12/Android%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>https://smallbluewhale.github.io/2016/12/12/Android部分知识的原理/</id>
    <published>2016-12-11T17:23:00.000Z</published>
    <updated>2017-02-07T03:28:34.287Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发进程通信"><a href="#并发进程通信" class="headerlink" title="并发进程通信"></a>并发进程通信</h1><p><strong>文件传输</strong>  </p>
<ul>
<li>writeObject的方式  </li>
</ul>
<p><strong>bundle</strong>  </p>
<p><strong>SharePreference</strong>  </p>
<ul>
<li>SharePreference的进程访问不可靠                             <ul>
<li>本质上shareprefence属于文件的一种，但由于系统对它的读写有一定的缓存策略，即在内存中会有一份SharePrefences文件的缓存，因此在多线程模式下，系统对它的读写就变的不可靠了</li>
</ul>
</li>
</ul>
<p><strong>Messenger</strong>  </p>
<p><strong>SharePreference</strong>  </p>
<h1 id="To-do-后续补充"><a href="#To-do-后续补充" class="headerlink" title="To do(后续补充)"></a>To do(后续补充)</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;并发进程通信&quot;&gt;&lt;a href=&quot;#并发进程通信&quot; class=&quot;headerlink&quot; title=&quot;并发进程通信&quot;&gt;&lt;/a&gt;并发进程通信&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;文件传输&lt;/strong&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;writeObject的方式  &lt;
    
    </summary>
    
      <category term="tips" scheme="https://smallbluewhale.github.io/categories/tips/"/>
    
    
      <category term="Android" scheme="https://smallbluewhale.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android学习总结</title>
    <link href="https://smallbluewhale.github.io/2016/12/12/Android%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>https://smallbluewhale.github.io/2016/12/12/Android学习总结/</id>
    <published>2016-12-11T17:23:00.000Z</published>
    <updated>2017-04-24T03:30:33.539Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自定义View学习中的一些难点记录"><a href="#自定义View学习中的一些难点记录" class="headerlink" title="自定义View学习中的一些难点记录"></a>自定义View学习中的一些难点记录</h1><ul>
<li>what is the different about getLeft(),getX()？  </li>
</ul>
<p><code>Position</code>  </p>
<ul>
<li><a href="&quot;http://gold.xitu.io/entry/571a591a2e958a006be9f473&quot;">这个部分可以参照这个地方去理解</a> </li>
</ul>
<p><strong>The geometry of a view is that of a rectangle. A view has a location, expressed as a pair of left and top coordinates, and two dimensions, expressed as a width and a height. The unit for location and dimensions is the pixel.</strong></p>
<p><strong>It is possible to retrieve the location of a view by invoking the methods getLeft() and getTop(). The former returns the left, or X, coordinate of the rectangle representing the view. The latter returns the top, or Y, coordinate of the rectangle representing the view. These methods both return the location of the view relative to its parent. For instance, when getLeft() returns 20, that means the view is located 20 pixels to the right of the left edge of its direct parent.</strong></p>
<p><strong>In addition, several convenience methods are offered to avoid unnecessary computations, namely getRight() and getBottom(). These methods return the coordinates of the right and bottom edges of the rectangle representing the view. For instance, calling getRight() is similar to the following computation: getLeft() + getWidth() (see Size for more information about the width.)</strong>  </p>
<pre><code>right = left + width;

bottom = top + height;
</code></pre><p>这里的意思是getLeft其实是相对父view的位置，而getX则是相对整个根布局的位置  </p>
<ul>
<li><p>View的滑动                            </p>
<ul>
<li><a href="&quot;http://gold.xitu.io/entry/576a264f80dda4005fb17639&quot;">关于getscrollX以及ScrollX的理解和梳理</a> </li>
</ul>
</li>
<li><p>关于自定义view中onMeasure方法的模板<br>​                 private Bitmap mBitmap;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">private void init() &#123;</div><div class="line">    mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.meinv);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">    // 获取宽度测量规格中的mode和size</div><div class="line">    int widthMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">    int widthSize = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">    int heightMode = MeasureSpec.getMode(heightMeasureSpec);</div><div class="line">    int heightSize = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line">    // 声明一个临时变量来存储计算出的测量值</div><div class="line">    int  heightResult = 0;</div><div class="line">    int widthResult = 0;</div><div class="line">  </div><div class="line">     /*</div></pre></td></tr></table></figure>
<ul>
<li><p>如果父容器心里有数<br>*/<br> if (widthMode == MeasureSpec.EXACTLY) {</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 那么子view就用父容器给定尺寸</div><div class="line">widthResult = widthSize;</div></pre></td></tr></table></figure>
<p> }<br> /*</p>
<ul>
<li>如果父容器不确定自身大小<br><em>/<br>else{<br> // 那么子view可要自己看看自己需要多大了<br> widthResult = mBitmap.getWidth()+getPaddingLeft()+getPaddingRight();<br> /</em><ul>
<li>如果爹给儿子的是一个限制值</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*/</div></pre></td></tr></table></figure>
<p>   if (widthMode == MeasureSpec.AT_MOST) {</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 那么儿子自己的需求就要跟爹的限制比比看谁小要谁</div><div class="line">widthResult = Math.min(widthSize, widthResult);</div></pre></td></tr></table></figure>
<p>   }<br>}</p>
<p> if (heightMode == MeasureSpec.EXACTLY) {</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">heightResult = widthSize;</div></pre></td></tr></table></figure>
<p>   }else{</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//考虑padding</div><div class="line">heightResult = mBitmap.getHeight()+getPaddingBottom()+getPaddingTop();</div><div class="line">if (heightMode == MeasureSpec.AT_MOST) &#123;</div><div class="line">    heightResult = Math.min(widthSize, heightResult);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>   }<br>   // 设置测量尺寸<br>   setMeasuredDimension(widthResult, heightResult);</p>
<p>}</p>
</li>
<li><p>关于自定义View滑动冲突的拦截以及模板总结、</p>
</li>
</ul>
<h1 id="外部拦截法"><a href="#外部拦截法" class="headerlink" title="外部拦截法"></a>外部拦截法</h1><h2 id="事件分发的过程图"><a href="#事件分发的过程图" class="headerlink" title="事件分发的过程图"></a>事件分发的过程图</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://ww2.sinaimg.cn/large/005Xtdi2jw1f88i0q8uozj30nm0kqwhm.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>外部拦截法即事件都经过父容器处理，如果父容器需要事件就处理事件，不需要则不拦截，下面来看一下伪代码：</p>
<pre><code>@Override
public boolean onInterceptTouchEvent(MotionEvent event) {
    boolean intercept = false;
    int x = (int) event.getX();
    int y = (int) event.getY();
    int action = event.getActionMasked();
    switch (action) {
        case MotionEvent.ACTION_DOWN:
            //如果希望子view能接收到事件，DOWN必然要返回false
            intercept = false;
            break;

        case MotionEvent.ACTION_MOVE:
            //如果需要拦截事件，就返回true
            if (needIntercept(event)) {
                intercept = true;
            } else {
                intercept = false;
            }
            break;

        case MotionEvent.ACTION_UP:
            //手指抬起，必须返回false，因为返回值对自己没有影响，而对子view可能有影响
            intercept = false;
            break;
    }
    //重新设置最后一次位置
    mLastEventX = x;
    mLastEventY = y;
    return intercept;
}

private boolean needIntercept(MotionEvent event) {
    return false;
}
</code></pre><p>下面来分析一下这段伪代码的意思：</p>
<ol>
<li>首先ACTION_DOWN必须返回false，否则子view无法接收到事件，事件都会由自己处理</li>
<li>对应ACTION_MOVE则对自己根据情况处理，需要就拦截，否则不拦截</li>
<li>最后是ACTION_UP，必须返回false，原因有：</li>
</ol>
<ul>
<li>ACTION_UP的返回值对自身并没有影响，自身始终能接收到事件</li>
<li>如果子一些列事件中，ViewGroup都始终没有拦截事件，却在ACTION_UP中返回true，这样导致子view无法接收到UP事件，那么就会影响子view的click事件，或者其他逻辑处理</li>
</ul>
<ol>
<li><p>是否需要拦截事件都交给needIntercept方法处理，这个处理是根据业务来处理的，还可如果我们无法确定某些因素，还可以通过设置回调接口来处理，让其他对象通过接口来告知感兴趣的事。</p>
<p>如下面代码：</p>
<pre><code> private boolean needIntercept(MotionEvent event) {
    if (mEventCallback != null) {
       return mEventCallback.isCanIntercept();
    }
    return false;
}

public EventCallback mEventCallback;

public void setEventCallback(EventCallback eventCallback) {
    mEventCallback = eventCallback;
}
public interface EventCallback{
    boolean isCanIntercept();
}
</code></pre></li>
</ol>
<p>在外部拦截法中，子view最好不要使用requestDisallowInterceptTouchEvent来干预事件的处理</p>
<h1 id="内部拦截法"><a href="#内部拦截法" class="headerlink" title="内部拦截法"></a>内部拦截法</h1><p>内部拦截是指父容器不拦截任何事件，所有事件都传递给子view，如果子元素需要事件就直接消耗，否则交给父容器处理，这种拦截法需要配合requestDisallowInterceptTouchEvent方法来使用。我们需要重写子view的dispatchTouchEvent方法。</p>
<pre><code>private int mLastX, mLastY;
  @Override
  public boolean dispatchTouchEvent(MotionEvent event) {
      int action = event.getActionMasked();
      int x = (int) event.getX();
      int y = (int) event.getY();
      switch (action) {
          case MotionEvent.ACTION_DOWN:
              //不让父View拦截事件
              mLastX = x;
              mLastY = y;
              getParent().requestDisallowInterceptTouchEvent(true);
              break;

          case MotionEvent.ACTION_MOVE:
              //如果需要拦截事件，就返回true
              if (!needIntercept(event)) {
                  getParent().requestDisallowInterceptTouchEvent(false);
              }
              break;

          case MotionEvent.ACTION_UP:
              //手指抬起，必须返回false，因为返回值对自己没有影响，而对子view可能有影响
              break;
      }
      mLastX = x;
      mLastY = y;
      return super.dispatchTouchEvent(event);
  }
</code></pre><p>代码说明：</p>
<ul>
<li>首先，必须假定父view不拦截DOWN事件而拦截其他事件，否则子view无法获取任何事件。在子view调用requestDisallowInterceptTouchEvent(false)后，父view才能继续拦截事件</li>
<li>其次在ACTION_DOWN时，调用requestDisallowInterceptTouchEvent(true)来不允许父View拦截事件</li>
<li>ACTION_MOVE中如果needIntercept返回false，则调用requestDisallowInterceptTouchEvent(false)让父view重新拦截事件，需要注意的是，一点调用此方法，就表示放弃了同系列的事件的所有事件。</li>
<li>最后调用requestDisallowInterceptTouchEvent后触发我们的onTouchEvent方法，处理时间</li>
</ul>
<p>所以父元素的拦截逻辑如下：</p>
<pre><code>@Override
  public boolean onInterceptHoverEvent(MotionEvent event) {
      boolean intercept = false;
      int x = (int) event.getX();
      int y = (int) event.getY();
      int action = event.getActionMasked();
      if(action == MotionEvent.ACTION_DOWN){
               return false;
      }else{
               return true
      }
 }  
</code></pre><h1 id="重定义dispatchTouchEvent方法"><a href="#重定义dispatchTouchEvent方法" class="headerlink" title="重定义dispatchTouchEvent方法"></a>重定义dispatchTouchEvent方法</h1><p>上面两种方法基本还是尊重系统的事件分发机制，但是还是有一些情况无法满足，这时候，我们需要根据业务需求来重新定义事件分发了。</p>
<p>比如一个下拉刷新模式</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="img/010_demopng.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>首先我们定义：<br>下拉刷新容器为： A<br>列表布局为ListView：B<br>刷新头为：C</p>
<p>逻辑如下：<br>首先A或获取到事件，如果手机方向被认定为垂直滑动，A要判断C的位置和滑动方向：</p>
<p>1，C刚好隐藏，此时向下滑动，B这时无法向下滑动</p>
<p>A需要拦截事件，自己处理，让C显示出来，此时A需要拦截事件，自己处理，让C显示出来，如果手指又向上滑动，则A又要判断C是否隐藏，没有隐藏还是A拦截并处理事件，当C完全隐藏后，又要吧事件交给B处理，B来实现自己列表View该有的特性</p>
<p>就这个逻辑上述方案1和方案2就无法满足，<strong>因为系统的事件分发有一个特点</strong>：</p>
<ul>
<li><p><strong>当一个ViewGroup开始拦截并处理事件后，这个事件只能由它来处理，不可能再把事件交给它的子view处理，要么它消费事件，要么最后交给Activity的onTouchEvent处理</strong></p>
<blockquote>
<p>在代码中就是，只要ViewGroup拦截了事件，他的dispatchTouchEvent方法中接收事件的子view就会被置为null，</p>
</blockquote>
</li>
</ul>
<p>此特点：</p>
<ul>
<li>套用到方案1外部拦截法就是，在MOVE中，开始拦截事件，View收到一个Cancel事件后，之后都无法获取到同系列事件了。</li>
<li>套用到方案2就是在MOVE中调用requestDisallowInterceptTouchEvent(false)就表示完全放弃同系列事件的所有事件了</li>
</ul>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p>说了这么方案，现在来一个实例，需求<br>定义一个ViewGroup，布局方向为横向布局，可以左右滑动切换子view，同时只显示一个子view，类似ViewPager，其次ViewGroup内部放置ListView，来制造滑动冲突，我们需要解决这种冲突。</p>
<p>我们的自定义HScrollLayout代码如下：</p>
<pre><code>package com.ztiany.view.views;

import android.content.Context;
import android.util.AttributeSet;
import android.util.Log;
import android.view.MotionEvent;
import android.view.VelocityTracker;
import android.view.View;
import android.view.ViewGroup;
import android.view.animation.AccelerateDecelerateInterpolator;
import android.widget.Scroller;

/**
 * @author Ztiany
 *         email 1169654504@qq.com &amp; ztiany3@gmail.com
 *         date 2015-12-03 15:23
 *         description
 *         vsersion
 */
public class HScrollLayout extends ViewGroup {


    public HScrollLayout(Context context) {
        this(context, null);
    }

    public HScrollLayout(Context context, AttributeSet attrs) {
        this(context, attrs, 0);
    }

    public HScrollLayout(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        init();
    }

    public static final String TAG = HScrollLayout.class.getSimpleName();

    private int mLastEventX, mLastEventY;
    private VelocityTracker mVelocityTracker;
    private Scroller mScroller;
    private int mWidth;
    private int mCurrentPage;


    private void init() {
        //设置方向为横向布局
        mScroller = new Scroller(getContext(), new AccelerateDecelerateInterpolator());
        mVelocityTracker = VelocityTracker.obtain();

    }


    @Override
    public boolean onInterceptTouchEvent(MotionEvent event) {

        if (getChildCount() &lt; 0) {
            return false;
        }


        boolean intercept = false;
        int x = (int) event.getX();
        int y = (int) event.getY();
        int action = event.getActionMasked();
        switch (action) {
            case MotionEvent.ACTION_DOWN:

                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                    intercept = true;
                } else {
                    //如果希望子view能接收到事件，DOWN必然要返回false
                    intercept = false;
                    mLastEventX = x;
                    mLastEventX = y;
                }


                break;

            case MotionEvent.ACTION_MOVE:
                //计算移动差
                int dx = x - mLastEventX;
                int dy = y - mLastEventY;
                if (Math.abs(dx) &gt; Math.abs(dy)) {
                    intercept = true;
                } else {
                    intercept = false;
                }
                break;

            case MotionEvent.ACTION_UP:
                //手指抬起，必须返回false，因为返回值对自己没有影响，而对子view可能有影响
                intercept = false;
                break;
        }
        mLastEventX = x;
        mLastEventY = y;
        return intercept;

    }

    @Override
    protected void onLayout(boolean changed, int l, int t, int r, int b) {
        Log.d(TAG, &quot;l:&quot; + l);
        Log.d(TAG, &quot;t:&quot; + t);
        Log.d(TAG, &quot;r:&quot; + r);
        Log.d(TAG, &quot;b:&quot; + b);
        int left = l, top = t, right = r, bottom = b;
        if (changed) {
            int childCount = getChildCount();
            View child;
            for (int i = 0; i &lt; childCount; i++) {
                child = getChildAt(i);
                if (child.getVisibility() == View.GONE) {
                    continue;
                }
                child.layout(left, top, left + child.getMeasuredWidth(), bottom);
                left += child.getMeasuredWidth();
            }
        }

    }


    @Override
    public boolean onTouchEvent(MotionEvent event) {

        mVelocityTracker.addMovement(event);
        int x = (int) event.getX();
        int y = (int) event.getY();
        int action = event.getActionMasked();
        switch (action) {
            case MotionEvent.ACTION_DOWN:
                mLastEventX = x;
                mLastEventX = y;
                break;

            case MotionEvent.ACTION_MOVE:
                int dx = x - mLastEventX;
                scrollBy(-dx, 0);

                break;

            case MotionEvent.ACTION_UP:
            case MotionEvent.ACTION_CANCEL:
                //将要滑动的距离
                int distanceX;
                mVelocityTracker.computeCurrentVelocity(1000);
                float xVelocity = mVelocityTracker.getXVelocity();

                Log.d(TAG, &quot;xVelocity:&quot; + xVelocity);

                if (Math.abs(xVelocity) &gt; 50) {
                    if (xVelocity &gt; 0) {//向左
                        mCurrentPage--;
                    } else {
                        mCurrentPage++;
                    }


                } else {
                    // 不考虑加速度
                    Log.d(TAG, &quot;getScrollX():&quot; + getScrollX());
                    if (getScrollX() &lt; 0) {//说明超出左边界
                        mCurrentPage = 0;
                    } else {
                        int childCount = getChildCount();
                        int maxScroll = (childCount - 1) * mWidth;
                        Log.d(TAG, &quot;maxScroll:&quot; + maxScroll);
                        if (getScrollX() &gt; maxScroll) {//超出了右边界
                            mCurrentPage = getChildCount() - 1;
                        } else {

                            //在边界范围内滑动
                            int currentScrollX = mCurrentPage * mWidth;//已近产生的偏移
                            int offset = getScrollX() % mWidth;
                            Log.d(TAG, &quot;mWidth:&quot; + mWidth);
                            Log.d(TAG, &quot;offset:&quot; + offset);

                            if (currentScrollX &gt; Math.abs(getScrollX())) {//向左偏移

                                if (offset &lt; (mWidth - mWidth / 3)) {//小于其 2/3
                                    mCurrentPage--;
                                } else {

                                }

                            } else {//向右偏移

                                if (offset &gt; mWidth / 3) {//小于其 2/3
                                    mCurrentPage++;
                                } else {

                                }

                            }

                        }
                    }
                    //不考虑加速度
                }
                mCurrentPage = (mCurrentPage &lt; 0) ? 0 : ((mCurrentPage &gt; (getChildCount() - 1)) ? (getChildCount() - 1) : mCurrentPage);
                distanceX = mCurrentPage * mWidth - getScrollX();
                Log.d(TAG, &quot;distanceX:&quot; + distanceX);
                smoothScroll(distanceX, 0);
                mVelocityTracker.clear();
                break;
        }
        mLastEventX = x;
        mLastEventY = y;
        //返回true，处理事件
        return true;
    }

    private void smoothScroll(int distanceX, int distanceY) {
        mScroller.startScroll(getScrollX(), 0, distanceX, 0, 500);
        invalidate();
    }

    @Override
    public void computeScroll() {
        if (mScroller.computeScrollOffset()) {
            scrollTo(mScroller.getCurrX(), mScroller.getCurrY());
            invalidate();
        }
    }

    /**
     * 重写测量逻辑
     *
     * @param widthMeasureSpec
     * @param heightMeasureSpec 这里我们不考虑wrap_content的情况,也不考虑子view的margin情况
     */
    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {

        int widthSize = MeasureSpec.getSize(widthMeasureSpec);
        int heightSize = MeasureSpec.getSize(heightMeasureSpec);

        int childCount = getChildCount();
        View child;
        for (int i = 0; i &lt; childCount; i++) {
            child = getChildAt(i);
            if (child.getVisibility() == View.GONE) {
                continue;
            }
            measureChild(child, MeasureSpec.makeMeasureSpec(widthSize, MeasureSpec.EXACTLY),
                    MeasureSpec.makeMeasureSpec(heightSize, MeasureSpec.EXACTLY));
        }


        setMeasuredDimension(widthSize, heightSize);
    }

    @Override
    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
        mWidth = w;
    }
}
</code></pre><p><img src="img/010_view滑动冲突解决方案.gif" alt=""></p>
<h1 id="事件分发流程"><a href="#事件分发流程" class="headerlink" title="事件分发流程"></a>事件分发流程</h1><p>通过前面的事件分发研究，我们可以总结出事件分发的流程：</p>
<p>在ViewGroup的dispatchTouchEvent中</p>
<ol>
<li><p>处理DOWN事件，在down事件中，如果拦截了事件则自己处理(onTouchEvent方法被调用)，子无法在获取事件了，如果不拦截DOWN事件，则会从外到内查找是否有子view能处理事件，如果有一个子view可以处理事件(down返回true)，则接下来的事件交给子view处理，ViewGroup的onInterceptTouchEvent方法还是会被调用，一旦其返回true，那么ViewGroup开始拦截事件，而子view以一个cancel事件结束</p>
</li>
<li><p>接下来的move和up事件，如果在down中没有找到可以处理事件的子view，则自己处理接下来的事件。</p>
</li>
<li><p>如果有子view可以处理事件，并且不拦截事件，则把事件都交给子view处理，一旦ViewGroup开始拦截，那么接收事件的子view将会被赋值为null，接下来事件遵循第二点。</p>
</li>
<li><p>如果子view能接收到DWON事件，并且在接收到事件事件后，调用requestDisallowInterceptTouchEvent(true)方法，ViewGroup无法再拦截事件，也就说requestDisallowInterceptTouchEvent优先级高于onInterceptTouchEvent，但是requestDisallowInterceptTouchEvent不能干预父view对DOWN事件的处理。对于DOWN事件onInterceptTouchEvent说了算。</p>
</li>
</ol>
<h2 id="Matrix的使用"><a href="#Matrix的使用" class="headerlink" title="Matrix的使用"></a>Matrix的使用</h2><h3 id="mapPoints"><a href="#mapPoints" class="headerlink" title="mapPoints"></a>mapPoints</h3><p>void mapPoints (float[] pts)</p>
<p>void mapPoints (float[] dst, float[] src)</p>
<p>void mapPoints (float[] dst, int dstIndex,float[] src, int srcIndex, int pointCount)</p>
<p>计算一组点基于当前Matrix变换后的位置，(由于是计算点，所以参数中的float数组长度一般都是偶数的,若为奇数，则最后一个数值不参与计算)。</p>
<p>它有三个重载方法:</p>
<ol>
<li><p>void mapPoints (float[] pts) 方法仅有一个参数，pts数组作为参数传递原始数值，计算结果仍存放在pts中。</p>
</li>
<li><p>void mapPoints (float[] dst, float[] src) ，src作为参数传递原始数值，计算结果存放在dst中，src不变。<br>如果原始数据需要保留则一般使用这种方法。</p>
</li>
<li><p>void mapPoints (float[] dst, int dstIndex,float[] src, int srcIndex, int pointCount) 可以指定只计算一部分数值。</p>
<p>参数摘要<br>dst目标数据<br>dstIndex目标数据存储位置起始下标<br>src源数据<br>srcIndex源数据存储位置起始下标<br>pointCount计算的点个数</p>
</li>
</ol>
<h2 id="关于事件分发的规律总结-参考Android开发艺术探索"><a href="#关于事件分发的规律总结-参考Android开发艺术探索" class="headerlink" title="关于事件分发的规律总结(参考Android开发艺术探索)"></a>关于事件分发的规律总结(参考Android开发艺术探索)</h2><ol>
<li><p><strong>同一个事件序列</strong>是指从手指触摸屏幕那一刻起，到手指离开屏幕的那一刻结束,所以一些列事件由：<br><code>一个DOWN + 不数量的MOVE + 一个UP事件(可能CANCEL)</code><br>组成</p>
</li>
<li><p>正常情况下，<strong>一个事件只能被一个View拦截和消费</strong>，也就是说同一个事件不可能被两个View共同来消费，但是如果一个View接收到事件并处理后有分发给其他View处理除外。</p>
</li>
<li><p>如果一个ViewGroup能接收到事件，并且开始拦截事件，那么这一系列事件只能由它来处理。并且他的onInterceptTouchEvent方法不会再被调用。</p>
<p>关于ViewGroup能否接收到事件又分为两种：</p>
</li>
</ol>
<ul>
<li>在DOWN就开始拦截事件</li>
<li>在DOWN没有拦截事件，但是子view处理了DOWN事件并且没有改变FLAG_DISALLOW_INTERCEPT这个标志位来不允许父View拦截事件，之后ViewGroup的onInterceptTouchEvent依然会被调用，如果返回true，ViewGroup还是可以拦截事件，之后可接收事件的子View收到一个CANCEL事件，然后在ViewGroup中被置为null</li>
</ul>
<ol>
<li><p>FLAG_DISALLOW_INTERCEPT 和 touchTarget在一系列事件的开始和结尾都会被重置,也就是说子View无法使用requestDisallowInterceptTouchEvent方法来要影响DOWN事件，如果ViewGroup在DOWN就开始拦截事件，子view不可能再得到事件</p>
</li>
<li><p>如果一个View开始接收事件，如果它不消费DOWN事件(DOWN中返回false)，那么它不会接收到同系列事件中接下来的事件，在源码中的体现就是，ViewGroup在DOWN事件中没有找到可以处理事件的子view，接下来的同系列事件就会自己处理，即他的onTouchEvent方法被调用</p>
</li>
<li><p>如果一个View开始接收事件，如果它消费了DOWN事件(DOWN中返回true),但是接下来的事件它返回false，这个View依然能继续接收这一系列的事件，直到UP(或CANCEL)事件结束，最终事件会回到Activity的onTouchEvent方法，由Activity处理</p>
</li>
<li><p>View不拦截事件，它接收到事件会里面调用onTouchEvent方法，ViewGroup默认不拦截事件</p>
</li>
<li><p>如果一个View是可以被click或者longClick的，那么它的onTouchEvent方法默认都会消费事件，即使它是不可用的(disable)，disable只会导致click或者longClick不被调用：</p>
</li>
</ol>
<ul>
<li>onClick发生前提，View可以点击，View能接收到Down和Up事件</li>
</ul>
<ol>
<li><p>focus对View的点击事件有影响，View的isFocusable和isFocusableInTouchMode为true并且当前没有获取到焦点，则会先请求焦点，此次点击不会响应click等事件</p>
</li>
<li><p>事件是由外到内进行传递的，由内到外进行处理的，即事件总是先传给根View，再由根View传递给子View，而默认的处理顺序是子View到根View，ViewGroup可以全部拦截事件，子View可以调用requestDisallowInterceptTouchEvent干预父View的事件分发(DOWN事件无法被干预)</p>
</li>
<li><p>当然对于某些特殊的需求，系统的dispatchTouchEvent方法可能不适用，那么需要重写ViewGroup的dispatchTouchEvent方法，那么事件分发的逻辑完全有我们定义。只要ViewGroup能接收到事件，它的dispatchTouchEvent每次都会被调用。</p>
</li>
<li><p>如果ACTION_DOWN事件发生在某个View的范围之内，则后续的ACTION_MOVE，ACTION_UP和ACTION_CANCEL等事件都将被发往该View，即使事件已经出界了。</p>
</li>
<li><p>第一根按下的手指触发ACTION_DOWN事件，之后按下的手指触发ACTION_POINTER_DOWN事件，中间起来的手指触发ACTION_POINTER_UP事件，最后起来的手指触发ACTION_UP事件（即使它不是触发ACTION_DOWN事件的那根手指）。</p>
</li>
<li><p>pointer id可以用于跟踪手指，从按下的那个时刻起pointer id生效，直至起来的那一刻失效，这之间维持不变（后续MotionEvent会详细解读）。</p>
</li>
<li><p>如果父View在onInterceptTouchEvent中拦截了事件，则onInterceptTouchEvent中不会再收到Touch事件了，事件被直接交给它自己处理（按照普通View的处理方式）。</p>
</li>
<li><p>如果一个事件首先由子view处理，但是如果子view在处理的过程中某个时刻返回了false，则此事件序列全部交给Activity处理。</p>
</li>
</ol>
<h2 id="关于事件分发中的滑动冲突"><a href="#关于事件分发中的滑动冲突" class="headerlink" title="关于事件分发中的滑动冲突"></a>关于事件分发中的滑动冲突</h2><p>常见的滑动冲突场景：</p>
<ul>
<li>1，外部滑动方向与内部滑动方向不一致</li>
<li>2，内部滑动方向与外部滑动方向一致</li>
<li>3，上述两种情况的嵌套</li>
</ul>
<p>####滑动冲突场景：</p>
<p>场景1：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="img/008_左右上下冲突.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>类似ViewPager与多个ListFragemnt嵌套</p>
<p>场景2：</p>
<p><img src="img/008_同向冲突.png" alt=""></p>
<p>类似ViewPager与ViewPager的嵌套</p>
<p>场景3：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="img/008_复杂冲突.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>类似SlidMenu加ViewPager加ListFragment</p>
<p>###解决滑动冲突的规则</p>
<ul>
<li>对于场景1有以下方法来解决</li>
<li>判断滑动路径与水平方向夹角</li>
<li>判断水平方向与垂直方向的距离差(常用)</li>
<li><p>判断水平方向与垂直方向的速度差</p>
</li>
<li><p>对于场景2</p>
</li>
<li>这能通过业务需求来解决，比如某个情况只允许哪个View滑动</li>
</ul>
<h1 id="关于动画一些内容-下次用的时候可以直接从这里copy代码"><a href="#关于动画一些内容-下次用的时候可以直接从这里copy代码" class="headerlink" title="关于动画一些内容(下次用的时候可以直接从这里copy代码)"></a>关于动画一些内容(下次用的时候可以直接从这里copy代码)</h1><ul>
<li><p>贝塞尔以及其它类型动画的一些总结  </p>
<p>  <a href="&quot;http://www.jianshu.com/p/420da0f6e279&quot;">各种常用动画效果的汇总</a>  </p>
</li>
<li><p>AnimationSet  </p>
<p>多个动画的组合  </p>
<pre><code>AnimationSet as = new AnimationSet(true);
</code></pre></li>
<li><p>ScaleAnimation  </p>
<p>变大变小动画</p>
<pre><code>ScaleAnimation sa = new ScaleAnimation(1f, 1.5f, 1f, 1.5f, ScaleAnimation.RELATIVE_TO_SELF,
        0.5f, ScaleAnimation.RELATIVE_TO_SELF, 0.5f);
sa.setDuration(ANIMATIONEACHOFFSET * 3);
sa.setRepeatCount(10);// 设置循环
</code></pre></li>
<li><p>AlphaAnimation  </p>
<p>透明度动画  </p>
<pre><code>AlphaAnimation aniAlp = new AlphaAnimation(1, 0.1f);
aniAlp.setRepeatCount(10);// 设置循环
as.setDuration(ANIMATIONEACHOFFSET * 3);
</code></pre><p>最后用一个addAnimation讲动画加进这个控件中  </p>
<pre><code>as.addAnimation(sa);
as.addAnimation(aniAlp);
</code></pre><p>开始一个动画labelicon是一个view  </p>
<pre><code>labelIcon.startAnimation(as);
</code></pre></li>
<li>怎么让多个组合动画重复执行？<br>stackoverflow：<br> <a href="&quot;http://stackoverflow.com/questions/17622333/repeat-animatorset&quot;">第二个回答，给animatorset加一个监听器</a>   </li>
</ul>
<p>示例：  </p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; 
&lt;!--First Stage  --&gt;
&lt;set  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;   
  android:ordering=&quot;together&quot;&gt;  
    &lt;objectAnimator 
        android:valueType=&quot;floatType&quot;
        android:duration=&quot;500&quot;
        android:propertyName=&quot;alpha&quot;
        android:valueFrom=&quot;1&quot;
        android:valueTo=&quot;0.8&quot;
        &gt;
    &lt;/objectAnimator&gt;

    &lt;objectAnimator 
        android:valueType=&quot;floatType&quot;
        android:duration=&quot;500&quot;
        android:propertyName=&quot;scaleX&quot;
        android:valueFrom=&quot;1&quot;
        android:valueTo=&quot;0.8&quot;
        &gt;
    &lt;/objectAnimator&gt;

    &lt;objectAnimator 
        android:valueType=&quot;floatType&quot;
        android:duration=&quot;500&quot;
        android:propertyName=&quot;scaleY&quot;
        android:valueFrom=&quot;1&quot;
        android:valueTo=&quot;0.8&quot;
        &gt;
    &lt;/objectAnimator&gt;

    &lt;objectAnimator
        android:propertyName=&quot;x&quot;
        android:duration=&quot;500&quot;
        android:valueFrom=&quot;0&quot;
        android:valueTo=&quot;20&quot;
        &gt;
    &lt;/objectAnimator&gt;

    &lt;objectAnimator
        android:propertyName=&quot;y&quot;
        android:duration=&quot;500&quot;
        android:valueFrom=&quot;0&quot;
        android:valueTo=&quot;-20&quot;
        &gt;
    &lt;/objectAnimator&gt;
</code></pre><p>​<br>        <!--Second Stage  --><br>        <objectanimator android:valuetype="floatType" android:startoffset="500" android:duration="500" android:propertyname="alpha" android:valuefrom="0.8" android:valueto="0.65"><br>        </objectanimator></p>
<pre><code>    &lt;objectAnimator 
        android:startOffset=&quot;500&quot;
        android:valueType=&quot;floatType&quot;
        android:duration=&quot;500&quot;
        android:propertyName=&quot;scaleX&quot;
        android:valueFrom=&quot;0.8&quot;
        android:valueTo=&quot;0.65&quot;
        &gt;
    &lt;/objectAnimator&gt;

    &lt;objectAnimator 
        android:startOffset=&quot;500&quot;
        android:valueType=&quot;floatType&quot;
        android:duration=&quot;500&quot;
        android:propertyName=&quot;scaleY&quot;
        android:valueFrom=&quot;0.8&quot;
        android:valueTo=&quot;0.65&quot;
        &gt;
    &lt;/objectAnimator&gt;

    &lt;objectAnimator
        android:startOffset=&quot;500&quot;
        android:propertyName=&quot;x&quot;
        android:duration=&quot;500&quot;
        android:valueFrom=&quot;20&quot;
        android:valueTo=&quot;-20&quot;
        &gt;
    &lt;/objectAnimator&gt;

    &lt;!--Third Stage  --&gt;
    &lt;objectAnimator 
        android:startOffset=&quot;1000&quot;
        android:valueType=&quot;floatType&quot;
        android:duration=&quot;500&quot;
        android:propertyName=&quot;alpha&quot;
        android:valueFrom=&quot;0.65&quot;
        android:valueTo=&quot;1&quot;
        &gt;
    &lt;/objectAnimator&gt;

    &lt;objectAnimator 
        android:startOffset=&quot;1000&quot;
        android:valueType=&quot;floatType&quot;
        android:duration=&quot;500&quot;
        android:propertyName=&quot;scaleX&quot;
        android:valueFrom=&quot;0.65&quot;
        android:valueTo=&quot;1&quot;
        &gt;
    &lt;/objectAnimator&gt;

    &lt;objectAnimator 
        android:startOffset=&quot;1000&quot;
        android:valueType=&quot;floatType&quot;
        android:duration=&quot;500&quot;
        android:propertyName=&quot;scaleY&quot;
        android:valueFrom=&quot;0.65&quot;
        android:valueTo=&quot;1&quot;
        &gt;
    &lt;/objectAnimator&gt;

    &lt;objectAnimator
        android:startOffset=&quot;1000&quot;
        android:propertyName=&quot;x&quot;
        android:duration=&quot;500&quot;
        android:valueFrom=&quot;-20&quot;
        android:valueTo=&quot;0&quot;
        &gt;
    &lt;/objectAnimator&gt;

    &lt;objectAnimator
        android:startOffset=&quot;1000&quot;
        android:propertyName=&quot;y&quot;
        android:duration=&quot;500&quot;
        android:valueFrom=&quot;-20&quot;
        android:valueTo=&quot;0&quot;
        &gt;
    &lt;/objectAnimator&gt;
&lt;/set&gt;
</code></pre><p>android代码部分：<br>​<br>    AnimatorSet animator =    (AnimatorSet) AnimatorInflater.loadAnimator(this,<br>                R.animator.clock_rotate);<br>        animator.setTarget(mFloatingImageView);<br>        animator.addListener(new AnimatorListener() {<br>            @Override<br>            public void onAnimationStart(Animator animation) {<br>                // TODO Auto-generated method stub<br>                mCanceled = false;<br>            }</p>
<pre><code>    @Override
    public void onAnimationRepeat(Animator animation) {
        // TODO Auto-generated method stub

    }

    @Override
    public void onAnimationEnd(Animator animation) {
        // TODO Auto-generated method stub
        if (!mCanceled) {
            animation.start();
          }
    }

    @Override
    public void onAnimationCancel(Animator animation) {
        // TODO Auto-generated method stub
        mCanceled = true;
    }
});
animator.start();
</code></pre><h1 id="Android-Splash秒开以及Activity白屏，黑屏的原因和过程"><a href="#Android-Splash秒开以及Activity白屏，黑屏的原因和过程" class="headerlink" title="Android Splash秒开以及Activity白屏，黑屏的原因和过程"></a>Android Splash秒开以及Activity白屏，黑屏的原因和过程</h1><ul>
<li><a href="&quot;http://blog.csdn.net/yanzhenjie1003/article/details/52201896&quot;"> Android Splash页秒开</a> </li>
</ul>
<p>MultiDex的简要原理   </p>
<pre><code>我们以APK中有两个dex文件为例，第二个dex文件为classes2.dex。  
兼容包在Applicaion实例化之后，会检查系统版本是否支持 multidex，classes2.dex是否需要安装。  
如果需要安装则会从APK中解压出classes2.dex并将其拷贝到应用的沙盒目录下。  
通过反射将classes2.dex注入到当前的classloader中。  
</code></pre><p>美团的解决方案(推荐后两篇文章)  </p>
<ul>
<li><a href="&quot;http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=207151651&amp;idx=1&amp;sn=9eab282711f4eb2b4daf2fbae5a5ca9a&amp;3rd=MzA3MDU4NTYzMw==&amp;scene=6#rd&quot;"> Android拆分与加载Dex的多种方案对比(手机QQ，微信)</a> </li>
</ul>
<p>手机QQ，微信的解决方案  </p>
<ul>
<li><a href="&quot;http://tech.meituan.com/mt-android-auto-split-dex.html&quot;"> 美团Android DEX自动拆包及动态加载简介 </a>  </li>
</ul>
<p>综合解决方案  </p>
<ul>
<li><a href="&quot;http://blog.zongwu233.com/the-touble-of-multidex&quot;"> 其实你不知道MultiDex到底有多坑 </a>  </li>
</ul>
<h1 id="使用multidex时会出现的一些坑点，以及解决方式和部署步骤"><a href="#使用multidex时会出现的一些坑点，以及解决方式和部署步骤" class="headerlink" title="使用multidex时会出现的一些坑点，以及解决方式和部署步骤"></a>使用multidex时会出现的一些坑点，以及解决方式和部署步骤</h1><p>汇集解决所有办法的关键文章与插件 </p>
<ul>
<li><a href="&quot;https://github.com/TangXiaoLv/Android-Easy-MultiDex&quot;">Android傻瓜式分包插件</a> </li>
</ul>
<p>MultiDex的简要原理   </p>
<p>我们以APK中有两个dex文件为例，第二个dex文件为classes2.dex。<br>    兼容包在Applicaion实例化之后，会检查系统版本是否支持 multidex，classes2.dex是否需要安装。<br>    如果需要安装则会从APK中解压出classes2.dex并将其拷贝到应用的沙盒目录下。<br>    通过反射将classes2.dex注入到当前的classloader中。  </p>
<p>Android Dex 分包并根据multidex源码解析(热修复的基础)  </p>
<ul>
<li><a href="&quot;http://souly.cn/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/2016/02/25/android%E5%88%86%E5%8C%85%E5%8E%9F%E7%90%86/&quot;"> 少量multidex源码解析</a> </li>
</ul>
<p>Android Dex 分包指南  </p>
<ul>
<li><a href="&quot;http://www.jianshu.com/p/b38124d332be&quot;"> Android Dex 分包指南</a> </li>
</ul>
<p>手机QQ，微信的解决方案  </p>
<ul>
<li><a href="&quot;http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=207151651&amp;idx=1&amp;sn=9eab282711f4eb2b4daf2fbae5a5ca9a&amp;3rd=MzA3MDU4NTYzMw==&amp;scene=6#rd&quot;"> Android拆分与加载Dex的多种方案对比(手机QQ，微信)</a> </li>
</ul>
<p>美团的解决方案(推荐后两篇文章)  </p>
<ul>
<li><a href="&quot;http://tech.meituan.com/mt-android-auto-split-dex.html&quot;"> 美团Android DEX自动拆包及动态加载简介 </a>  </li>
</ul>
<p>综合解决方案  </p>
<ul>
<li><a href="&quot;http://blog.zongwu233.com/the-touble-of-multidex&quot;"> 其实你不知道MultiDex到底有多坑 </a>  </li>
</ul>
<h1 id="微信Tinker热修复原理"><a href="#微信Tinker热修复原理" class="headerlink" title="微信Tinker热修复原理"></a>微信Tinker热修复原理</h1><ul>
<li>热修复基本原理</li>
</ul>
<ul>
<li><a href="&quot;https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&amp;mid=400118620&amp;idx=1&amp;sn=b4fdd5055731290eef12ad0d17f39d4a&quot;">Android热修复原理(简单易懂)</a> </li>
</ul>
<ul>
<li>dex包全量替换的原理<br>为什么是65536个方法，因为short只能表示65536个方法，具体计算，short两个字节代表16位，16位就是2的16次方。</li>
<li>dex包全量替换的原理<br>因为这里他不能将新的dex直接加入补丁包中，这样会导致包大小太大，所以，这里他将差异包加入补丁包中(对比两个dex的差异)再将旧的dex和之前用bsdiff算法生成的差异对比后，形成一个新的dex，最后再解析出来，这样的话就很好的解决了这个问题。    </li>
</ul>
<ul>
<li><a href="&quot;https://www.qcloud.com/community/article/101&quot;">完整的方案以及tinker的原理</a> </li>
<li><a href="&quot;http://www.w2bc.com/article/179241&quot;">tinker源码分析</a> </li>
<li><a href="&quot;http://sparkinlee.github.io/2016/08/dex%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%8F%8Adexdiff%E5%8E%9F%E7%90%86&quot;">dex文件格式及dexdiff原理</a>  </li>
<li><a href="&quot;http://dev.qq.com/topic/57ad7a70eaed47bb2699e68e&quot;">微信热补丁 Tinker 的实践演进之路</a> </li>
<li><a href="&quot;https://github.com/dogriffiths/HeadFirstAndroid/wiki/How-Android-Apps-are-Built-and-Run#put-classesdex-and-resources-into-a-package-file&quot;">和android app运行过程相关(how apps built and run)</a> </li>
</ul>
<h1 id="一个Android-Studio上的实用工具"><a href="#一个Android-Studio上的实用工具" class="headerlink" title="一个Android Studio上的实用工具"></a>一个Android Studio上的实用工具</h1><p>这个工具是用来加入不同分辨率图片的工具  </p>
<ul>
<li><a href="&quot;http://blog.inet198.cn/?ziwang_/article/details/51713623&quot;"> Android Drawable Importer的使用 </a>  </li>
</ul>
<p>这个工具是用来统计类里面方法数  </p>
<ul>
<li><a href="&quot;http://inloop.github.io/apk-method-count/&quot;"> APK method count的使用 </a>  </li>
</ul>
<p>一个用来检测Android出现oom的库，测试，平时可用。  </p>
<ul>
<li><p><a href="&quot;https://github.com/square/leakcanary&quot;">  自动检测oom的库 </a></p>
<h1 id="gradle一些有用的学习资料"><a href="#gradle一些有用的学习资料" class="headerlink" title="gradle一些有用的学习资料"></a>gradle一些有用的学习资料</h1></li>
<li><p><a href="&quot;http://blog.csdn.net/sbsujjbcy/article/details/50782830&quot;"> 如何编写一个gradle插件 </a>  </p>
</li>
<li><p><a href="&quot;http://yifeng.studio/2016/09/06/apk-environment-separate&quot;"> gradle实现环境分离 </a>  </p>
</li>
<li><p><a href="&quot;http://www.infoq.com/cn/articles/android-in-depth-gradle&quot;"> 深入理解Android（一）：Gradle详解 </a>  </p>
</li>
</ul>
<h1 id="google上android的mvp结构基本实现方式以及如何规范的运用"><a href="#google上android的mvp结构基本实现方式以及如何规范的运用" class="headerlink" title="google上android的mvp结构基本实现方式以及如何规范的运用"></a>google上android的mvp结构基本实现方式以及如何规范的运用</h1><p><a href="&quot;http://dev.qq.com/topic/57bfef673c1174283d60bac0&quot;"> 基于RxJava的一种MVP实现 </a>  </p>
<p><a href="&quot;https://github.com/googlesamples/android-architecture/&quot;"> google规范mvp模式的运用 </a>  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;自定义View学习中的一些难点记录&quot;&gt;&lt;a href=&quot;#自定义View学习中的一些难点记录&quot; class=&quot;headerlink&quot; title=&quot;自定义View学习中的一些难点记录&quot;&gt;&lt;/a&gt;自定义View学习中的一些难点记录&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;what
    
    </summary>
    
    
      <category term="Android" scheme="https://smallbluewhale.github.io/tags/Android/"/>
    
  </entry>
  
</feed>
